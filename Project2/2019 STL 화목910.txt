
--------------------------------------------------------
Thu Mar  7 17:56:19 2019
--------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <fstream>
#include <iterator>
#include <string>
#include <chrono>

void save(std::string);

int main()
{
	save("소스.cpp");
}

void save(std::string name)
{
	//name을 읽기 모드로 오픈한다.
	std::ifstream in(name);
	//기록할 파일을 쓰기 모드(덧붙이기)로 오픈한다.
	std::ofstream out("2019 STL 화목910.txt", std::ios::app);
	//현재 시간을 string에 저장하기.
	auto now = std::chrono::system_clock::now();
	auto date = std::chrono::system_clock::to_time_t(now);
	std::string time(ctime(&date));
	//저장한 시간도 중요한다.
	out << std::endl << std::endl;
	out << "--------------------------------------------------------" << std::endl;
	out << time;
	out << "--------------------------------------------------------" << std::endl;
	out << std::endl;

	//모든 내용을 읽어서 쓴다.
	std::copy(std::istreambuf_iterator<char>(in), 
		std::istreambuf_iterator<char>(), 
		std::ostreambuf_iterator<char>(out));
}

-------------------------------
Thu Mar  7 17:57:43 2019
-------------------------------

#include <iostream>
#include <algorithm>
#include <fstream>
#include <iterator>
#include <string>
#include <chrono>

void save(std::string);

int main()
{
	save("소스.cpp");
}

void save(std::string name)
{
	//name을 읽기 모드로 오픈한다.
	std::ifstream in(name);
	//기록할 파일을 쓰기 모드(덧붙이기)로 오픈한다.
	std::ofstream out("2019 STL 화목910.txt", std::ios::app);
	//현재 시간을 string에 저장하기.
	auto now = std::chrono::system_clock::now();
	auto date = std::chrono::system_clock::to_time_t(now);
	std::string time(ctime(&date));
	//저장한 시간도 중요한다.
	out << std::endl << std::endl;
	out << "-------------------------------" << std::endl;
	out << time;
	out << "-------------------------------" << std::endl;
	out << std::endl;

	//모든 내용을 읽어서 쓴다.
	std::copy(std::istreambuf_iterator<char>(in), 
		std::istreambuf_iterator<char>(), 
		std::ostreambuf_iterator<char>(out));
}

-------------------------
Thu Mar  7 17:58:25 2019
-------------------------

#include <iostream>
#include <algorithm>
#include <fstream>
#include <iterator>
#include <string>
#include <chrono>

void save(std::string);

int main()
{
	save("소스.cpp");
}

void save(std::string name)
{
	//name을 읽기 모드로 오픈한다.
	std::ifstream in(name);
	//기록할 파일을 쓰기 모드(덧붙이기)로 오픈한다.
	std::ofstream out("2019 STL 화목910.txt", std::ios::app);
	//현재 시간을 string에 저장하기.
	auto now = std::chrono::system_clock::now();
	auto date = std::chrono::system_clock::to_time_t(now);
	std::string time(ctime(&date));
	//저장한 시간도 중요한다.
	out << std::endl << std::endl;
	out << "-------------------------" << std::endl;
	out << time;
	out << "-------------------------" << std::endl;
	out << std::endl;

	//모든 내용을 읽어서 쓴다.
	std::copy(std::istreambuf_iterator<char>(in), 
		std::istreambuf_iterator<char>(), 
		std::ostreambuf_iterator<char>(out));
}

=========================
Thu Mar  7 18:01:21 2019
=========================

#include "save.h"

int main()
{
	save("소스.cpp");
}



=========================
Thu Mar  7 18:21:09 2019
=========================

#include "save.h"

void save(std::string name)
{
	//name을 읽기 모드로 오픈한다.
	std::ifstream in(name);
	//기록할 파일을 쓰기 모드(덧붙이기)로 오픈한다.
	std::ofstream out("2019 STL 화목910.txt", std::ios::app);
	//현재 시간을 string에 저장하기.
	auto now = std::chrono::system_clock::now();
	auto date = std::chrono::system_clock::to_time_t(now);
	std::string time(ctime(&date));
	//저장한 시간도 중요한다.
	out << std::endl << std::endl;
	out << "=========================" << std::endl;
	out << time;
	out << "=========================" << std::endl;
	out << std::endl;

	//모든 내용을 읽어서 쓴다.
	std::copy(std::istreambuf_iterator<char>(in),
		std::istreambuf_iterator<char>(),
		std::ostreambuf_iterator<char>(out));
}

=========================
Thu Mar  7 18:32:02 2019
=========================

//------------------------------------------------------------
//2019.STL 3.7 목9,10
//
// - 자료를 파일에 저장해 보기
// - 랜덤 정수를 만들기
// - 정수를 정렬하기
// - 정렬한 결과를 파일에 저장하기
// - 파일에 저장한 정수를 읽어 화면에 출력하기
//
// - 책 내용은 다음 주 부터.....
//------------------------------------------------------------
#include "save.h"
using namespace std;

int main()
{
	int a[]{ 1,3,5,7,9,2,4,6,8,10 };

	sort(begin(a), end(a));

	save("소스.cpp");
}

=========================
Thu Mar  7 18:33:28 2019
=========================

//------------------------------------------------------------
//2019.STL 3.7 목9,10
//
// - 자료를 파일에 저장해 보기
// - 랜덤 정수를 만들기
// - 정수를 정렬하기
// - 정렬한 결과를 파일에 저장하기
// - 파일에 저장한 정수를 읽어 화면에 출력하기
//
// - 책 내용은 다음 주 부터.....
//------------------------------------------------------------
#include "save.h"
using namespace std;

int main()
{
	int a[]{ 1,3,5,7,9,2,4,6,8,10 };

	sort(begin(a), end(a));

	for (int d : a)
		cout << d << ' ';
	cout << endl;

	save("소스.cpp");
}

=========================
Thu Mar  7 18:38:09 2019
=========================

//------------------------------------------------------------
//2019.STL 3.7 목9,10
//
// - 자료를 파일에 저장해 보기
// - 랜덤 정수를 만들기
// - 정수를 정렬하기
// - 정렬한 결과를 파일에 저장하기
// - 파일에 저장한 정수를 읽어 화면에 출력하기
//
// - 책 내용은 다음 주 부터.....
//------------------------------------------------------------
#include "save.h"
using namespace std;

bool how(int a, int b) {
	return a > b;
}

int main()
{
	int a[]{ 1,3,5,7,9,2,4,6,8,10 };

	sort(&a[0],&a[10],how);

	for (int d : a)
		cout << d << ' ';
	cout << endl;

	save("소스.cpp");
}

=========================
Thu Mar  7 18:43:12 2019
=========================

//------------------------------------------------------------
//2019.STL 3.7 목9,10
//
// - 자료를 파일에 저장해 보기
// - 랜덤 정수를 만들기
// - 정수를 정렬하기
// - 정렬한 결과를 파일에 저장하기
// - 파일에 저장한 정수를 읽어 화면에 출력하기
//
// - 책 내용은 다음 주 부터.....
//------------------------------------------------------------
#include "save.h"
using namespace std;

int main()
{
	int a[]{ 1,3,5,7,9,2,4,6,8,10 };

	sort(begin(a), end(a), [](int a, int b) {
		return a > b;
	});

	for (int d : a)
		cout << d << ' ';
	cout << endl;

	save("소스.cpp");
}

=========================
Thu Mar  7 18:49:20 2019
=========================

//------------------------------------------------------------
//2019.STL 3.7 목9,10
//
// - 자료를 파일에 저장해 보기
// - 랜덤 정수를 만들기
// - 정수를 정렬하기
// - 정렬한 결과를 파일에 저장하기
// - 파일에 저장한 정수를 읽어 화면에 출력하기
//
// - 책 내용은 다음 주 부터.....
//------------------------------------------------------------
#include "save.h"
#include <random>
using namespace std;

int main()
{
	int a[10000];

	//10000개를 임의의 값으로 채워 넣자.
	uniform_int_distribution<> uid;
	default_random_engine dre;
	for (int i = 0; i < 10000; ++i)
		a[i] = uid(dre);

	/*sort(begin(a), end(a), [](int a, int b) {
		return a > b;
	});*/

	for (int d : a)
		cout << d << ' ';
	cout << endl;

	save("소스.cpp");
}

=========================
Thu Mar  7 18:52:11 2019
=========================

//------------------------------------------------------------
//2019.STL 3.7 목9,10
//
// - 자료를 파일에 저장해 보기
// - 랜덤 정수를 만들기
// - 정수를 정렬하기
// - 정렬한 결과를 파일에 저장하기
// - 파일에 저장한 정수를 읽어 화면에 출력하기
//
// - 책 내용은 다음 주 부터.....
//------------------------------------------------------------
#include "save.h"
#include <random>
using namespace std;

int main()
{
	int a[10000];

	//10000개를 임의의 값으로 채워 넣자.
	uniform_int_distribution<> uid;
	default_random_engine dre;
	for (int i = 0; i < 10000; ++i)
		a[i] = uid(dre);

	sort(begin(a), end(a));

	for (int d : a)
		cout << d << ' ';
	cout << endl;

	save("소스.cpp");
}

=========================
Thu Mar  7 18:52:30 2019
=========================

//------------------------------------------------------------
//2019.STL 3.7 목9,10
//
// - 자료를 파일에 저장해 보기
// - 랜덤 정수를 만들기
// - 정수를 정렬하기
// - 정렬한 결과를 파일에 저장하기
// - 파일에 저장한 정수를 읽어 화면에 출력하기
//
// - 책 내용은 다음 주 부터.....
//------------------------------------------------------------
#include "save.h"
#include <random>
using namespace std;

int main()
{
	int a[10000];

	//10000개를 임의의 값으로 채워 넣자.
	uniform_int_distribution<> uid(0,1000000);
	default_random_engine dre;
	for (int i = 0; i < 10000; ++i)
		a[i] = uid(dre);

	sort(begin(a), end(a));

	for (int d : a)
		cout << d << ' ';
	cout << endl;

	save("소스.cpp");
}

=========================
Thu Mar  7 18:54:06 2019
=========================

//------------------------------------------------------------
//2019.STL 3.7 목9,10
//
// - 자료를 파일에 저장해 보기
// - 랜덤 정수를 만들기
// - 정수를 정렬하기
// - 정렬한 결과를 파일에 저장하기
// - 파일에 저장한 정수를 읽어 화면에 출력하기
//
// - 책 내용은 다음 주 부터.....
//------------------------------------------------------------
#include "save.h"
#include <random>
using namespace std;

int main()
{
	int a[10000];

	//10000개를 임의의 값으로 채워 넣자.
	uniform_int_distribution<> uid(0,100000000);
	default_random_engine dre;
	for (int i = 0; i < 10000; ++i)
		a[i] = uid(dre);

	sort(begin(a), end(a));

	for (int d : a)
		cout << d << ' ';
	cout << endl;

	save("소스.cpp");
}

=========================
Thu Mar  7 18:57:14 2019
=========================

//------------------------------------------------------------
//2019.STL 3.7 목9,10
//
// - 자료를 파일에 저장해 보기
// - 랜덤 정수를 만들기
// - 정수를 정렬하기
// - 정렬한 결과를 파일에 저장하기
// - 파일에 저장한 정수를 읽어 화면에 출력하기
//
// - 책 내용은 다음 주 부터.....
//------------------------------------------------------------
#include "save.h"
#include <random>
using namespace std;

int main()
{
	int a[10000];

	//10000개를 임의의 값으로 채워 넣자.
	uniform_int_distribution<> uid(0,100000000);
	default_random_engine dre;
	for (int& d:a)
		d = uid(dre);

	sort(begin(a), end(a));

	for (int& d : a)
		cout << d << ' ';
	cout << endl;

	save("소스.cpp");
}

=========================
Tue Mar 12 17:47:43 2019
=========================

//------------------------------------------------------------
//2019.STL 3.12 화9,10
//
// - 자료를 파일에 저장해 보기
// - 랜덤 정수를 만들기
// - 정수를 정렬하기
// - 정렬한 결과를 파일에 저장하기
// - 파일에 저장한 정수를 읽어 화면에 출력하기
//
// - 이 내용을 객체로 (class Dog)
// - smart pointer
// - callable type
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// - 알고리즘 시간재기
// 구분자를 넣어도 문법 오류가 아님!
//------------------------------------------------------------
#include "save.h"
#include <random>
using namespace std;
// 정수 100만개를 전역변수로 만들었다.(100만개는 Data Segment에 위치한다.)
// 실행파일에는 어떤 변화가 있는가?
// int a[1'000'000];
// int a[1'000'000]{1};
// 이 두 경우를 살펴볼 것
int a[1'000'000];

int main()
{

	//10000개를 임의의 값으로 채워 넣자.
	uniform_int_distribution<> uid(0, 100000000);
	default_random_engine dre;
	for (int& d : a)
		d = uid(dre);

	sort(begin(a), end(a));

	// 정렬 후 앞에서 100개만 출력한다.
	for (int i = 0; i < 100; ++i)
		cout << a[i] << ' ';
	cout << endl;

	save("소스.cpp");
}

=========================
Tue Mar 12 17:48:06 2019
=========================

//------------------------------------------------------------
//2019.STL 3.12 화9,10
//
// - 자료를 파일에 저장해 보기
// - 랜덤 정수를 만들기
// - 정수를 정렬하기
// - 정렬한 결과를 파일에 저장하기
// - 파일에 저장한 정수를 읽어 화면에 출력하기
//
// - 이 내용을 객체로 (class Dog)
// - smart pointer
// - callable type
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// - 알고리즘 시간재기
// 구분자를 넣어도 문법 오류가 아님!
//------------------------------------------------------------
#include "save.h"
#include <random>
using namespace std;
// 정수 100만개를 전역변수로 만들었다.(100만개는 Data Segment에 위치한다.)
// 실행파일에는 어떤 변화가 있는가?
// int a[1'000'000];
// int a[1'000'000]{1};
// 이 두 경우를 살펴볼 것
int a[1'000'000];

int main()
{

	//10000개를 임의의 값으로 채워 넣자.
	uniform_int_distribution<> uid(0, 10);
	default_random_engine dre;
	for (int& d : a)
		d = uid(dre);

	sort(begin(a), end(a));

	// 정렬 후 앞에서 100개만 출력한다.
	for (int i = 0; i < 100; ++i)
		cout << a[i] << ' ';
	cout << endl;

	save("소스.cpp");
}

=========================
Tue Mar 12 17:48:46 2019
=========================

//------------------------------------------------------------
//2019.STL 3.12 화9,10
//
// - 자료를 파일에 저장해 보기
// - 랜덤 정수를 만들기
// - 정수를 정렬하기
// - 정렬한 결과를 파일에 저장하기
// - 파일에 저장한 정수를 읽어 화면에 출력하기
//
// - 이 내용을 객체로 (class Dog)
// - smart pointer
// - callable type
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// - 알고리즘 시간재기
// 구분자를 넣어도 문법 오류가 아님!
//------------------------------------------------------------
#include "save.h"
#include <random>
using namespace std;
// 정수 100만개를 전역변수로 만들었다.(100만개는 Data Segment에 위치한다.)
// 실행파일에는 어떤 변화가 있는가?
// int a[1'000'000];
// int a[1'000'000]{1};
// 이 두 경우를 살펴볼 것
int a[1'000'000];

int main()
{

	//10000개를 임의의 값으로 채워 넣자.
	uniform_int_distribution<> uid(0, 1'000'000);
	default_random_engine dre;
	for (int& d : a)
		d = uid(dre);

	sort(begin(a), end(a));

	// 정렬 후 앞에서 100개만 출력한다.
	for (int i = 0; i < 100; ++i)
		cout << a[i] << ' ';
	cout << endl;

	save("소스.cpp");
}

=========================
Tue Mar 12 17:54:45 2019
=========================

//------------------------------------------------------------
//2019.STL 3.12 화9,10
//
// - 자료를 파일에 저장해 보기
// - 랜덤 정수를 만들기
// - 정수를 정렬하기
// - 정렬한 결과를 파일에 저장하기
// - 파일에 저장한 정수를 읽어 화면에 출력하기
//
// - 이 내용을 객체로 (class Dog)
// - smart pointer
// - callable type
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// - 알고리즘 시간재기
// 구분자를 넣어도 문법 오류가 아님!
//------------------------------------------------------------
#include "save.h"
#include <random>
using namespace std;
// 정수 100만개를 전역변수로 만들었다.(100만개는 Data Segment에 위치한다.)
// 실행파일에는 어떤 변화가 있는가?
// int a[1'000'000];
// int a[1'000'000]{1};
// 이 두 경우를 살펴볼 것
// 전역 변수는 프로그램 종료 시에 메모리를 해제하기 때문에
// 낭비가 심해질 수 있다.
// 그러니 필요할 때만 사용할 수 있도록 하자.

int main()
{

	int* a=new int[1'000'000];
	//10000개를 임의의 값으로 채워 넣자.
	uniform_int_distribution<> uid(0, 1'000'000);
	default_random_engine dre;
	for (int i = 0; i < 1'000'000; ++i)
		a[i] = uid(dre);

	sort(a, a+1'000'000);

	// 정렬 후 앞에서 100개만 출력한다.
	for (int i = 0; i < 100; ++i)
		cout << a[i] << ' ';
	cout << endl;

	save("소스.cpp");
}

=========================
Tue Mar 12 17:59:30 2019
=========================

//------------------------------------------------------------
//2019.STL 3.12 화9,10
//
// - 자료를 파일에 저장해 보기
// - 랜덤 정수를 만들기
// - 정수를 정렬하기
// - 정렬한 결과를 파일에 저장하기
// - 파일에 저장한 정수를 읽어 화면에 출력하기
//
// - 이 내용을 객체로 (class Dog)
// - smart pointer
// - callable type
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// - 알고리즘 시간재기
// 구분자를 넣어도 문법 오류가 아님!
//------------------------------------------------------------
#include "save.h"
#include <random>
using namespace std;
// 정수 100만개를 전역변수로 만들었다.(100만개는 Data Segment에 위치한다.)
// 실행파일에는 어떤 변화가 있는가?
// int a[1'000'000];
// int a[1'000'000]{1};
// 이 두 경우를 살펴볼 것
// 전역 변수는 프로그램 종료 시에 메모리를 해제하기 때문에
// 낭비가 심해질 수 있다.
// 그러니 필요할 때만 사용할 수 있도록 하자.

int main()
{
	//사용자가 입력한 숫자만큼 정수를 확보하고 랜덤값으로 초기화 정렬 후 출력
	int* a;
	
	cout << "동적으로 할당할 정수의 갯수 : ";
	int num;
	cin >> num;

	//갯수만큼 할당
	a = new int[num];

	uniform_int_distribution<> uid(0, 1'000'000);
	default_random_engine dre;
	for (int i = 0; i < num; ++i)
		a[i] = uid(dre);

	//정렬 전 앞에서 100개 출력
	cout << "정렬 전" << endl;
	for (int i = 0; i < 100; ++i)
		cout << a[i] << ' ';
	cout << endl;

	sort(a, a+num);

	// 정렬 후 앞에서 100개만 출력한다.
	cout << "정렬 후" << endl;
	for (int i = 0; i < 100; ++i)
		cout << a[i] << ' ';
	cout << endl;

	save("소스.cpp");
}

=========================
Tue Mar 12 18:01:37 2019
=========================

//------------------------------------------------------------
//2019.STL 3.12 화9,10
//
// - 자료를 파일에 저장해 보기
// - 랜덤 정수를 만들기
// - 정수를 정렬하기
// - 정렬한 결과를 파일에 저장하기
// - 파일에 저장한 정수를 읽어 화면에 출력하기
//
// - 이 내용을 객체로 (class Dog)
// - smart pointer
// - callable type
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// - 알고리즘 시간재기
// 구분자를 넣어도 문법 오류가 아님!
//------------------------------------------------------------
#include "save.h"
#include <random>
using namespace std;
// 정수 100만개를 전역변수로 만들었다.(100만개는 Data Segment에 위치한다.)
// 실행파일에는 어떤 변화가 있는가?
// int a[1'000'000];
// int a[1'000'000]{1};
// 이 두 경우를 살펴볼 것
// 전역 변수는 프로그램 종료 시에 메모리를 해제하기 때문에
// 낭비가 심해질 수 있다.
// 그러니 필요할 때만 사용할 수 있도록 하자.

int main()
{
	//사용자가 입력한 숫자만큼 정수를 확보하고 랜덤값으로 초기화 정렬 후 출력
	int* a;

	//반복 구문 시작
	while(true)
	{
		cout << "동적으로 할당할 정수의 갯수 : ";
		int num;
		cin >> num;

		//갯수만큼 할당
		a = new int[num];

		uniform_int_distribution<> uid(0, 1'000'000);
		default_random_engine dre;
		for (int i = 0; i < num; ++i)
			a[i] = uid(dre);

		//정렬 전 앞에서 100개 출력
		cout << "정렬 전" << endl;
		for (int i = 0; i < 100; ++i)
			cout << a[i] << ' ';
		cout << endl;

		sort(a, a + num);

		// 정렬 후 앞에서 100개만 출력한다.
		cout << "정렬 후" << endl;
		for (int i = 0; i < 100; ++i)
			cout << a[i] << ' ';
		cout << endl;

		save("소스.cpp");

	}
}

=========================
Tue Mar 12 18:02:04 2019
=========================

//------------------------------------------------------------
//2019.STL 3.12 화9,10
//
// - 자료를 파일에 저장해 보기
// - 랜덤 정수를 만들기
// - 정수를 정렬하기
// - 정렬한 결과를 파일에 저장하기
// - 파일에 저장한 정수를 읽어 화면에 출력하기
//
// - 이 내용을 객체로 (class Dog)
// - smart pointer
// - callable type
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// - 알고리즘 시간재기
// 구분자를 넣어도 문법 오류가 아님!
//------------------------------------------------------------
#include "save.h"
#include <random>
using namespace std;
// 정수 100만개를 전역변수로 만들었다.(100만개는 Data Segment에 위치한다.)
// 실행파일에는 어떤 변화가 있는가?
// int a[1'000'000];
// int a[1'000'000]{1};
// 이 두 경우를 살펴볼 것
// 전역 변수는 프로그램 종료 시에 메모리를 해제하기 때문에
// 낭비가 심해질 수 있다.
// 그러니 필요할 때만 사용할 수 있도록 하자.

int main()
{
	//사용자가 입력한 숫자만큼 정수를 확보하고 랜덤값으로 초기화 정렬 후 출력
	int* a;

	//반복 구문 시작
	while(true)
	{
		cout << "동적으로 할당할 정수의 갯수 : ";
		int num;
		cin >> num;

		//갯수만큼 할당
		a = new int[num];

		uniform_int_distribution<> uid(0, 1'000'000);
		default_random_engine dre;
		for (int i = 0; i < num; ++i)
			a[i] = uid(dre);

		//정렬 전 앞에서 100개 출력
		cout << "정렬 전" << endl;
		for (int i = 0; i < 100; ++i)
			cout << a[i] << ' ';
		cout << endl;

		sort(a, a + num);

		// 정렬 후 앞에서 100개만 출력한다.
		cout << "정렬 후" << endl;
		for (int i = 0; i < 100; ++i)
			cout << a[i] << ' ';
		cout << endl;

		save("소스.cpp");

	}
}

=========================
Tue Mar 12 18:03:25 2019
=========================

//------------------------------------------------------------
//2019.STL 3.12 화9,10
//
// - 자료를 파일에 저장해 보기
// - 랜덤 정수를 만들기
// - 정수를 정렬하기
// - 정렬한 결과를 파일에 저장하기
// - 파일에 저장한 정수를 읽어 화면에 출력하기
//
// - 이 내용을 객체로 (class Dog)
// - smart pointer
// - callable type
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// - 알고리즘 시간재기
// 구분자를 넣어도 문법 오류가 아님!
//------------------------------------------------------------
#include "save.h"
#include <random>
using namespace std;
// 정수 100만개를 전역변수로 만들었다.(100만개는 Data Segment에 위치한다.)
// 실행파일에는 어떤 변화가 있는가?
// int a[1'000'000];
// int a[1'000'000]{1};
// 이 두 경우를 살펴볼 것
// 전역 변수는 프로그램 종료 시에 메모리를 해제하기 때문에
// 낭비가 심해질 수 있다.
// 그러니 필요할 때만 사용할 수 있도록 하자.

int main()
{
	//사용자가 입력한 숫자만큼 정수를 확보하고 랜덤값으로 초기화 정렬 후 출력
	int* a;

	//반복 구문 시작
	while(true)
	{
		cout << "동적으로 할당할 정수의 갯수 : ";
		int num;
		cin >> num;

		//갯수만큼 할당
		a = new int[num];

		uniform_int_distribution<> uid(0, 1'000'000);
		default_random_engine dre;
		for (int i = 0; i < num; ++i)
			a[i] = uid(dre);

		//정렬 전 앞에서 100개 출력
		cout << "정렬 전" << endl;
		for (int i = 0; i < 100; ++i)
			cout << a[i] << ' ';
		cout << endl;

		sort(a, a + num);

		// 정렬 후 앞에서 100개만 출력한다.
		cout << "정렬 후" << endl;
		for (int i = 0; i < 100; ++i)
			cout << a[i] << ' ';
		cout << endl;

		save("소스.cpp");

	}
}

=========================
Tue Mar 12 18:30:56 2019
=========================

//------------------------------------------------------------
//2019.STL 3.12 화9,10
//
// - 자료를 파일에 저장해 보기
// - 정렬한 결과를 파일에 저장하기
//
// - 이 내용을 객체로 (class Dog)
// - smart pointer
// - callable type
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// - 알고리즘 시간재기
// 구분자를 넣어도 문법 오류가 아님!
//------------------------------------------------------------
#include "save.h"
#include <random>
using namespace std;

//정수 만개를 랜덤값으로 초기화 정렬 후, (uid(dre), 0, 100'000)
//"정수만개오름차순.dat"으로 저장
//파일 크기를 생각하면서 작성

int main()
{
	uniform_int_distribution<> uid(0, 100'000);
	default_random_engine dre;

	int a[10000];

	for (int& d : a)
		d = uid(dre);

	sort(begin(a), end(a));

	ofstream out("정수만개오름차순.dat");

	for (int d : a)
		out << d << ' ';

	save("소스.cpp");
}

=========================
Tue Mar 12 18:32:42 2019
=========================

//------------------------------------------------------------
//2019.STL 3.12 화9,10
//
// - 자료를 파일에 저장해 보기
// - 정렬한 결과를 파일에 저장하기
//
// - 이 내용을 객체로 (class Dog)
// - smart pointer
// - callable type
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// - 알고리즘 시간재기
// 구분자를 넣어도 문법 오류가 아님!
//------------------------------------------------------------
#include "save.h"
#include <random>
using namespace std;

//정수 만개를 랜덤값으로 초기화 정렬 후, (uid(dre), 0, 100'000)
//"정수만개오름차순.dat"으로 저장
//파일 크기를 생각하면서 작성

int main()
{
	uniform_int_distribution<> uid;
	default_random_engine dre;

	int a[10000];

	for (int& d : a)
		d = uid(dre);

	sort(begin(a), end(a));

	ofstream out("정수만개오름차순.dat");

	for (int d : a)
		out << d << ' ';

	save("소스.cpp");
}

=========================
Tue Mar 12 18:35:50 2019
=========================

//------------------------------------------------------------
//2019.STL 3.12 화9,10
//
// - 자료를 파일에 저장해 보기
// - 정렬한 결과를 파일에 저장하기
//
// - 이 내용을 객체로 (class Dog)
// - smart pointer
// - callable type
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// - 알고리즘 시간재기
// 구분자를 넣어도 문법 오류가 아님!
//------------------------------------------------------------
#include "save.h"
#include <random>
using namespace std;

//정수 만개를 랜덤값으로 초기화 정렬 후, (uid(dre), 0, 100'000)
//"정수만개오름차순.dat"으로 저장
//파일 크기를 생각하면서 작성


//정수 만개를 저장하려면 필요한 공간은 몇 바이트인가?
int main()
{
	uniform_int_distribution<> uid(0,100'000);
	default_random_engine dre;

	int a[10000];

	for (int& d : a)
		d = uid(dre);

	sort(begin(a), end(a));

	ofstream out("정수만개오름차순.dat");

	int cnt = 1;
	for (int d : a)
	{
		if (cnt++ % 10 == 0)
		{
			cout << endl;
		}
		out << d << ' ';
	}

	save("소스.cpp");
}

=========================
Tue Mar 12 18:36:06 2019
=========================

//------------------------------------------------------------
//2019.STL 3.12 화9,10
//
// - 자료를 파일에 저장해 보기
// - 정렬한 결과를 파일에 저장하기
//
// - 이 내용을 객체로 (class Dog)
// - smart pointer
// - callable type
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// - 알고리즘 시간재기
// 구분자를 넣어도 문법 오류가 아님!
//------------------------------------------------------------
#include "save.h"
#include <random>
using namespace std;

//정수 만개를 랜덤값으로 초기화 정렬 후, (uid(dre), 0, 100'000)
//"정수만개오름차순.dat"으로 저장
//파일 크기를 생각하면서 작성


//정수 만개를 저장하려면 필요한 공간은 몇 바이트인가?
int main()
{
	uniform_int_distribution<> uid(0,100'000);
	default_random_engine dre;

	int a[10000];

	for (int& d : a)
		d = uid(dre);

	sort(begin(a), end(a));

	ofstream out("정수만개오름차순.dat");

	int cnt = 1;
	for (int d : a)
	{
		if (cnt++ % 10 == 0)
		{
			out << endl;
		}
		out << d << ' ';
	}

	save("소스.cpp");
}

=========================
Tue Mar 12 18:43:26 2019
=========================

//------------------------------------------------------------
//2019.STL 3.12 화9,10
//
// - 자료를 파일에 저장해 보기
// - 정렬한 결과를 파일에 저장하기
//
// - 이 내용을 객체로 (class Dog)
// - smart pointer
// - callable type
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// - 알고리즘 시간재기
// 구분자를 넣어도 문법 오류가 아님!
//------------------------------------------------------------
#include "save.h"
#include <random>
using namespace std;

//정수 만개를 랜덤값으로 초기화 정렬 후, (uid(dre), 0, 100'000)
//"정수만개오름차순.dat"으로 저장
//파일 크기를 생각하면서 작성


//정수 만개를 저장하려면 필요한 공간은 몇 바이트인가?
int main()
{
	uniform_int_distribution<> uid(0,100'000);
	default_random_engine dre;

	int a[10000];

	for (int& d : a)
		d = uid(dre);

	sort(begin(a), end(a));

	ofstream out("정수만개오름차순.dat");

	out.write((char*)a, 10'000 * sizeof(int));

	save("소스.cpp");
}

=========================
Tue Mar 12 18:46:43 2019
=========================

//------------------------------------------------------------
//2019.STL 3.12 화9,10
//
// - 자료를 파일에 저장해 보기
// - 정렬한 결과를 파일에 저장하기
//
// - 이 내용을 객체로 (class Dog)
// - smart pointer
// - callable type
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// - 알고리즘 시간재기
// 구분자를 넣어도 문법 오류가 아님!
//------------------------------------------------------------
#include "save.h"
#include <random>
using namespace std;

//정수 만개를 랜덤값으로 초기화 정렬 후, (uid(dre), 0, 100'000)
//"정수만개오름차순.dat"으로 저장
//파일 크기를 생각하면서 작성


//정수 만개를 저장하려면 필요한 공간은 몇 바이트인가? -> 4만 바이트
//파일은 2가지 모드로 열 수 있다.
// 1. default: text mode 또는 binary mode가 있다.
int main()
{
	uniform_int_distribution<> uid(0,100'000);
	default_random_engine dre;

	int a[10000];

	for (int& d : a)
		d = uid(dre);

	sort(begin(a), end(a));

	ofstream out("정수만개오름차순.dat",ios::binary);

	out.write((char*)a, 10'000 * sizeof(int));

	save("소스.cpp");
}

=========================
Tue Mar 12 18:54:18 2019
=========================

//------------------------------------------------------------
//2019.STL 3.12 화9,10
//
// - 자료를 파일에 저장해 보기
// - 정렬한 결과를 파일에 저장하기
//
// - 이 내용을 객체로 (class Dog)
// - smart pointer
// - callable type
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// - 알고리즘 시간재기
// 구분자를 넣어도 문법 오류가 아님!
//------------------------------------------------------------
#include "save.h"
#include <random>
using namespace std;

//파일 "정수만개오름차순.dat" 에는 정렬된 정수 만개가 바이너리로 저장되어 있다.
//이 파일을 읽어 화면에 출력하라.
int main()
{
	ofstream out("정수만개오름차순.dat", ios::binary);
	out.rdbuf();
	save("소스.cpp");
}

=========================
Tue Mar 12 18:54:30 2019
=========================

//------------------------------------------------------------
//2019.STL 3.12 화9,10
//
// - 자료를 파일에 저장해 보기
// - 정렬한 결과를 파일에 저장하기
//
// - 이 내용을 객체로 (class Dog)
// - smart pointer
// - callable type
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// - 알고리즘 시간재기
// 구분자를 넣어도 문법 오류가 아님!
//------------------------------------------------------------
#include "save.h"
#include <random>
using namespace std;

//파일 "정수만개오름차순.dat" 에는 정렬된 정수 만개가 바이너리로 저장되어 있다.
//이 파일을 읽어 화면에 출력하라.
int main()
{
	ofstream out("정수만개오름차순.dat", ios::binary);
	out.rdbuf();
	save("소스.cpp");
}

=========================
Tue Mar 12 18:54:56 2019
=========================

//------------------------------------------------------------
//2019.STL 3.12 화9,10
//
// - 자료를 파일에 저장해 보기
// - 정렬한 결과를 파일에 저장하기
//
// - 이 내용을 객체로 (class Dog)
// - smart pointer
// - callable type
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// - 알고리즘 시간재기
// 구분자를 넣어도 문법 오류가 아님!
//------------------------------------------------------------
#include "save.h"
#include <random>
using namespace std;

//파일 "정수만개오름차순.dat" 에는 정렬된 정수 만개가 바이너리로 저장되어 있다.
//이 파일을 읽어 화면에 출력하라.
int main()
{
	uniform_int_distribution<> uid(0,100'000);
	default_random_engine dre;

	int a[10000];

	for (int& d : a)
		d = uid(dre);

	sort(begin(a), end(a));

	ofstream out("정수만개오름차순.dat",ios::binary);

	out.write((char*)a, 10'000 * sizeof(int));

	save("소스.cpp");
}

=========================
Tue Mar 12 19:01:49 2019
=========================

//------------------------------------------------------------
//2019.STL 3.12 화9,10
//
// - 자료를 파일에 저장해 보기
// - 정렬한 결과를 파일에 저장하기
//
// - 이 내용을 객체로 (class Dog)
// - smart pointer
// - callable type
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// - 알고리즘 시간재기
// 구분자를 넣어도 문법 오류가 아님!
//------------------------------------------------------------
#include "save.h"
#include <random>
#include <iomanip>
using namespace std;

//파일 "정수만개오름차순.dat" 에는 정렬된 정수 만개가 바이너리로 저장되어 있다.
//이 파일을 읽어 화면에 출력하라.
//파일 아파에는 파일의 정보를 가지고 있는 헤더가 있다.
int main()
{
	ifstream in("정수만개오름차순.dat", ios::binary);
	int* a = new int[10000];
	in.read((char*)a, 40000);

	int cnt = 1;
	for (int i = 0; i < 10000; ++i)
	{
		cout << setw(12) << a[i];
		if (cnt++ % 6 == 0)
			cout << '\n';
	}
	save("소스.cpp");
}

=========================
Thu Mar 14 17:45:26 2019
=========================

//------------------------------------------------------------
//2019.STL 3.12 화9,10
//
// - 자료를 파일에 저장해 보기
// - 정렬한 결과를 파일에 저장하기
//
// - 이 내용을 객체로 (class Dog)
// - smart pointer
// - callable type
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// - 알고리즘 시간재기
// 구분자를 넣어도 문법 오류가 아님!
//------------------------------------------------------------
#include "save.h"
#include <random>
using namespace std;

//Dog 1000마리를 임의의 값으로 생성한다.
//이름 순으로 정렬하여 "개천마리.dat"에 저장한다.
//파일 크기를 확인한다.(sizeof(Dog)*1000 바이트가 되어야 한다.)

uniform_int_distribution<> uid(0, 20);
uniform_int_distribution<> uidName('a', 'z');
default_random_engine dre;

class Dog {
	char name[11]; //임의의 알파벳 10글자로 이름을 채우자
	int age; //uid(dre) (0,20)사이의 값으로 설정
public:
	Dog() {
		age = uid(dre);

		for (int i = 0; i < 10; ++i)
		{
			name[i] = uidName(dre);
		}
		name[10] = '\0';
	}
	~Dog() {};

	string getName() const {
		return string(name);
	}
	//friend ostream& operator<<(ostream& os, const Dog& dog);
};

Dog dogs[1000];

int main()
{
	sort(begin(dogs), end(dogs), [](const Dog& a,const Dog& b) {
		return a.getName() < b.getName();
	});

	ofstream out("개천마리.dat", ios::binary);
	out.write((char*)dogs, sizeof(Dog) * 1000);

	save("소스.cpp");
}

=========================
Thu Mar 14 17:55:48 2019
=========================

//------------------------------------------------------------
//2019.STL 3.12 화9,10
//
// - 자료를 파일에 저장해 보기
// - 정렬한 결과를 파일에 저장하기
//
// - 이 내용을 객체로 (class Dog)
// - smart pointer
// - callable type
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// - 알고리즘 시간재기
// 구분자를 넣어도 문법 오류가 아님!
//------------------------------------------------------------
#include "save.h"
#include <random>
using namespace std;

//Dog 1000마리를 임의의 값으로 생성한다.
//이름 순으로 정렬하여 "개천마리.dat"에 저장한다.
//파일 크기를 확인한다.(sizeof(Dog)*1000 바이트가 되어야 한다.)

uniform_int_distribution<> uid(0, 20);
uniform_int_distribution<> uidName('a', 'z');
default_random_engine dre;

class Dog {
	char name[11]; //임의의 알파벳 10글자로 이름을 채우자
	int age; //uid(dre) (0,20)사이의 값으로 설정
public:
	Dog() {
		/*age = uid(dre);

		for (int i = 0; i < 10; ++i)
		{
			name[i] = uidName(dre);
		}
		name[10] = '\0';*/
	}
	~Dog() {};

	string getName() const {
		return string(name);
	}
	//friend ostream& operator<<(ostream& os, const Dog& dog);
};

//파일 "개천마리.dat"에 이름순으로 정렬되어있다.
//읽어서 한 줄마다 다음 형식으로 화면에 출력하라.
//이름 : asdfasdf	나이 : 3살

int main()
{
	ifstream in("개천마리.dat", ios::binary);
	
	Dog dog;
	in.read((char*)&dog, sizeof(Dog));
	cout << "이름 : " << (char*)&dog << "나이 : " << endl;

	save("소스.cpp");
}

=========================
Thu Mar 14 17:56:38 2019
=========================

//------------------------------------------------------------
//2019.STL 3.12 화9,10
//
// - 자료를 파일에 저장해 보기
// - 정렬한 결과를 파일에 저장하기
//
// - 이 내용을 객체로 (class Dog)
// - smart pointer
// - callable type
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// - 알고리즘 시간재기
// 구분자를 넣어도 문법 오류가 아님!
//------------------------------------------------------------
#include "save.h"
#include <random>
using namespace std;

//Dog 1000마리를 임의의 값으로 생성한다.
//이름 순으로 정렬하여 "개천마리.dat"에 저장한다.
//파일 크기를 확인한다.(sizeof(Dog)*1000 바이트가 되어야 한다.)

uniform_int_distribution<> uid(0, 20);
uniform_int_distribution<> uidName('a', 'z');
default_random_engine dre;

class Dog {
	char name[11]; //임의의 알파벳 10글자로 이름을 채우자
	int age; //uid(dre) (0,20)사이의 값으로 설정
public:
	Dog() {
		/*age = uid(dre);

		for (int i = 0; i < 10; ++i)
		{
			name[i] = uidName(dre);
		}
		name[10] = '\0';*/
	}
	~Dog() {};

	string getName() const {
		return string(name);
	}
	//friend ostream& operator<<(ostream& os, const Dog& dog);
};

//파일 "개천마리.dat"에 이름순으로 정렬되어있다.
//읽어서 한 줄마다 다음 형식으로 화면에 출력하라.
//이름 : asdfasdf	나이 : 3살

int main()
{
	ifstream in("개천마리.dat", ios::binary);

	Dog dog;
	for (int i = 0; i < 1000; ++i)
	{
		in.read((char*)&dog, sizeof(Dog));
		cout << "이름 : " << (char*)&dog << "나이 : " << endl;

	}

	save("소스.cpp");
}

=========================
Thu Mar 14 18:02:51 2019
=========================

//------------------------------------------------------------
//2019.STL 3.12 화9,10
//
// - 자료를 파일에 저장해 보기
// - 정렬한 결과를 파일에 저장하기
//
// - 이 내용을 객체로 (class Dog)
// - smart pointer
// - callable type
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// - 알고리즘 시간재기
// - 자원을 확보하는 클래스를 만들어 놓기
// 구분자를 넣어도 문법 오류가 아님!
//------------------------------------------------------------
#include "save.h"
#include <random>
using namespace std;

uniform_int_distribution<> uid(0, 20);
uniform_int_distribution<> uidName('a', 'z');
default_random_engine dre;

class Dog {
	char name[11]; //임의의 알파벳 10글자로 이름을 채우자
	int age; //uid(dre) (0,20)사이의 값으로 설정
public:
	Dog() {
		/*age = uid(dre);

		for (int i = 0; i < 10; ++i)
		{
			name[i] = uidName(dre);
		}
		name[10] = '\0';*/
	}
	~Dog() {};

	string getName() const {
		return string(name);
	}
	friend ostream& operator<<(ostream& os, const Dog& dog);
};

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << "이름 : " << dog.name << "	나이 : " << dog.age << "살"<<endl;
	return os;
}

//파일 "개천마리.dat"에 이름순으로 정렬되어있다.
//읽어서 한 줄마다 다음 형식으로 화면에 출력하라.
//이름 : asdfasdf	나이 : 3살

int main()
{
	ifstream in("개천마리.dat", ios::binary);

	Dog dog;
	for (int i = 0; i < 1000; ++i)
	{
		in.read((char*)&dog, sizeof(Dog));
		cout << dog;

	}

	save("소스.cpp");
}

=========================
Thu Mar 14 18:07:19 2019
=========================

//------------------------------------------------------------
//2019.STL 3.14 목9,10
// - smart pointer
// - callable type
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// - 알고리즘 시간재기
// - 자원을 확보하는 클래스를 만들어 놓기
// 구분자를 넣어도 문법 오류가 아님!
//------------------------------------------------------------
#include "save.h"
#include <thread>
#include <random>
using namespace std;

//프로그램의 실행시간을 재는 방법

int main()
{
	//123밀리 초동안 프로그램 시간을 쓰는 코드
	this_thread::sleep_for(123ms);

	save("소스.cpp");
}

=========================
Thu Mar 14 18:07:41 2019
=========================

//------------------------------------------------------------
//2019.STL 3.14 목9,10
// - smart pointer
// - callable type
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// - 알고리즘 시간재기
// - 자원을 확보하는 클래스를 만들어 놓기
// 구분자를 넣어도 문법 오류가 아님!
//------------------------------------------------------------
#include "save.h"
#include <thread>
#include <random>
using namespace std;

//프로그램의 실행시간을 재는 방법

int main()
{
	//123밀리 초동안 프로그램 시간을 쓰는 코드
	this_thread::sleep_for(5s);

	save("소스.cpp");
}

=========================
Thu Mar 14 18:15:21 2019
=========================

//------------------------------------------------------------
//2019.STL 3.14 목9,10
// - smart pointer
// - callable type
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// - 알고리즘 시간재기
// - 자원을 확보하는 클래스를 만들어 놓기
// 구분자를 넣어도 문법 오류가 아님!
//------------------------------------------------------------
#include "save.h"
#include <thread>
#include <random>
using namespace std;

//프로그램의 실행시간을 재는 방법

int main()
{

	auto b=chrono::steady_clock::now();//시간재기 시작
	this_thread::sleep_for(123ms);
	auto e=chrono::steady_clock::now();//시간재기 끝

	auto d = e - b;

	cout << d.count() << endl;

	save("소스.cpp");
}

=========================
Thu Mar 14 18:17:47 2019
=========================

//------------------------------------------------------------
//2019.STL 3.14 목9,10
// - smart pointer
// - callable type
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// - 알고리즘 시간재기
// - 자원을 확보하는 클래스를 만들어 놓기
// 구분자를 넣어도 문법 오류가 아님!
//------------------------------------------------------------
#include "save.h"
#include <thread>
#include <random>
using namespace std;

//프로그램의 실행시간을 재는 방법

int main()
{

	auto b=chrono::steady_clock::now();//시간재기 시작
	this_thread::sleep_for(12s);
	auto e=chrono::steady_clock::now();//시간재기 끝

	auto d = e - b;
	auto t = chrono::duration_cast<chrono::milliseconds>(d);


	cout << t.count() << "밀리초 경과" <<endl;

	save("소스.cpp");
}

=========================
Thu Mar 14 18:23:07 2019
=========================

//------------------------------------------------------------
//2019.STL 3.14 목9,10
// - smart pointer
// - callable type
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// - 알고리즘 시간재기
// - 자원을 확보하는 클래스를 만들어 놓기
// 구분자를 넣어도 문법 오류가 아님!
//------------------------------------------------------------
#include "save.h"
#include <thread>
#include <random>
using namespace std;

//프로그램의 실행시간을 재는 방법

int main()
{

	auto b=chrono::steady_clock::now();//시간재기 시작
	this_thread::sleep_for(123ms);
	auto t = chrono::duration_cast<chrono::milliseconds>(chrono::steady_clock::now() - b);


	cout << t.count() << "밀리초 경과" <<endl;

	save("소스.cpp");
}

=========================
Thu Mar 14 18:23:13 2019
=========================

//------------------------------------------------------------
//2019.STL 3.14 목9,10
// - smart pointer
// - callable type
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// - 알고리즘 시간재기
// - 자원을 확보하는 클래스를 만들어 놓기
// 구분자를 넣어도 문법 오류가 아님!
//------------------------------------------------------------
#include "save.h"
#include <thread>
#include <random>
using namespace std;

//프로그램의 실행시간을 재는 방법

int main()
{

	auto b=chrono::steady_clock::now();//시간재기 시작
	this_thread::sleep_for(123ms);
	auto t = chrono::duration_cast<chrono::milliseconds>(chrono::steady_clock::now() - b);


	cout << t.count() << "밀리초 경과" <<endl;

	save("소스.cpp");
}

=========================
Thu Mar 14 18:23:29 2019
=========================

//------------------------------------------------------------
//2019.STL 3.14 목9,10
// - smart pointer
// - callable type
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// - 알고리즘 시간재기
// - 자원을 확보하는 클래스를 만들어 놓기
// 구분자를 넣어도 문법 오류가 아님!
//------------------------------------------------------------
#include "save.h"
#include <thread>
#include <random>
using namespace std;

//프로그램의 실행시간을 재는 방법

int main()
{

	auto b=chrono::steady_clock::now();//시간재기 시작
	this_thread::sleep_for(123456us);
	auto t = chrono::duration_cast<chrono::milliseconds>(chrono::steady_clock::now() - b);


	cout << t.count() << "밀리초 경과" <<endl;

	save("소스.cpp");
}

=========================
Thu Mar 14 18:24:14 2019
=========================

//------------------------------------------------------------
//2019.STL 3.14 목9,10
// - smart pointer
// - callable type
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// - 알고리즘 시간재기
// - 자원을 확보하는 클래스를 만들어 놓기
// 구분자를 넣어도 문법 오류가 아님!
//------------------------------------------------------------
#include "save.h"
#include <thread>
#include <random>
using namespace std;

//프로그램의 실행시간을 재는 방법

int main()
{

	auto b=chrono::steady_clock::now();//시간재기 시작
	this_thread::sleep_for(123456us);
	auto t = chrono::duration_cast<chrono::microseconds>(chrono::steady_clock::now() - b);


	cout << t.count() << "마이크로초 경과" <<endl;

	save("소스.cpp");
}

=========================
Thu Mar 14 18:48:18 2019
=========================

//------------------------------------------------------------
//2019.STL 3.14 목9,10
// - smart pointer
// - callable type
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// - 알고리즘 시간재기
// - 자원을 확보하는 클래스를 만들어 놓기
// 구분자를 넣어도 문법 오류가 아님!
//------------------------------------------------------------
#include "save.h"
using namespace std;

void jump() {
	cout << "점프" << endl;
}

void slide() {
	cout << "슬라이드" << endl;
}

class Dog {
public:
	void operator()() {
		cout << "CRAZY DOG" << endl;
	}
};

//프로그램의 실행시간을 재는 방법

int main()
{
	void(*f)() = jump;

	f();	//f는 함수포인터로 호출가능타입의 일종

	auto g = []() {
		cout << "lambda" << endl;
	};		//람다또한 호출가능타입의 일종
	g();

	Dog d;
	d();	//d는 호출가능한 객체

	save("소스.cpp");
}

=========================
Thu Mar 14 19:01:34 2019
=========================

//------------------------------------------------------------
//2019.STL 3.14 목9,10
// - smart pointer
// - callable type
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// - 알고리즘 시간재기
// - 자원을 확보하는 클래스를 만들어 놓기
// 구분자를 넣어도 문법 오류가 아님!
//------------------------------------------------------------
#include "save.h"
#include <functional>
using namespace std;

void jump() {
	cout << "점프" << endl;
}

void slide() {
	cout << "슬라이드" << endl;
}

class Dog {
public:
	void operator()() {
		cout << "CRAZY DOG" << endl;
	}
	void bark() {
		cout << "BITTEN!" << endl;
	}
};

//프로그램의 실행시간을 재는 방법

int main()
{
	function<void()>f = jump;

	f();	//f는 함수포인터로 호출가능타입의 일종

	function<void()>g = []() {
		cout << "lambda" << endl;
	};		//람다또한 호출가능타입의 일종
	g();

	Dog d;
	function<void(Dog)> eh=&Dog::operator();	//d는 호출가능한 객체

	function<void(Dog)> h = &Dog::bark;
	h(d);//????????이건 뭐냐

	save("소스.cpp");
}

=========================
Tue Mar 19 17:30:02 2019
=========================

//------------------------------------------------------------
//2019.STL 3.19 화9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// - 알고리즘 시간재기
// - 자원을 확보하는 클래스를 만들어 놓기
// 구분자를 넣어도 문법 오류가 아님!
//------------------------------------------------------------
#include "save.h"
#include <functional>
using namespace std;

void jump() {
	cout << "점프" << endl;//요건 함수다
}

void slide() {
	cout << "슬라이드" << endl;
}

class Dog {
public:
	void operator()() {
		cout << "CRAZY DOG" << endl;
	}
	void bark() {
		cout << "BITTEN!" << endl;
	}
};

//프로그램의 실행시간을 재는 방법

int main()
{
	//void (*f1)(void) =jump; 이게 고전적인 방법.
	//cout << typeid(f1).name() << endl; 함수포인터라고 출력됨.

	[]() {cout << "람다" << endl; }();
	save("소스.cpp");
}

=========================
Tue Mar 19 17:31:26 2019
=========================

//------------------------------------------------------------
//2019.STL 3.19 화9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// - 알고리즘 시간재기
// - 자원을 확보하는 클래스를 만들어 놓기
// 구분자를 넣어도 문법 오류가 아님!
//------------------------------------------------------------
#include "save.h"
#include <functional>
using namespace std;

void jump() {
	cout << "점프" << endl;//요건 함수다
}

void slide() {
	cout << "슬라이드" << endl;
}

class Dog {
public:
	void operator()() {
		cout << "CRAZY DOG" << endl;
	}
	void bark() {
		cout << "BITTEN!" << endl;
	}
};

//프로그램의 실행시간을 재는 방법

int main()
{
	//void (*f1)(void) =jump; 이게 고전적인 방법.
	//cout << typeid(f1).name() << endl; 함수포인터라고 출력됨.

	auto f2 = []() {cout << "람다" << endl; };//함수인데 이름이 없어요
	cout << typeid(f2).name() << endl;
	save("소스.cpp");
}

=========================
Tue Mar 19 17:38:32 2019
=========================

//------------------------------------------------------------
//2019.STL 3.19 화9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// - 알고리즘 시간재기
// - 자원을 확보하는 클래스를 만들어 놓기
// 구분자를 넣어도 문법 오류가 아님!
//------------------------------------------------------------
#include "save.h"
#include <functional>
using namespace std;

void jump() {
	cout << "점프" << endl;//요건 함수다
}

void slide() {
	cout << "슬라이드" << endl;
}

class Dog {
public:
	void operator()() {
		cout << "CRAZY DOG" << endl;
	}
	void bark() {
		cout << "BITTEN!" << endl;
	}
};

int main()
{
	//void (*f1)(void) =jump; 이게 고전적인 방법.
	//cout << typeid(f1).name() << endl; 함수포인터라고 출력됨.

	//auto f2 = []() {cout << "람다" << endl; };//함수인데 이름이 없어요
	//cout << typeid(f2).name() << endl;//완전히 다른 타입이 튀어나온다.
	//함수는 언제나 전역함수로 선언해야 하지만,
	//람다는 지역에서 사용이 가능하다. []을 캡쳐라고 한다.
	//[]로 전역의 함수를 가져올 수 있다.
	
	Dog d;
	void (Dog::*f3)(void) = &Dog::operator();//void(Dog::*f3)(void)=&Dog::operator();
	
	cout << typeid(f3).name() << endl;

	save("소스.cpp");
}

=========================
Tue Mar 19 17:39:45 2019
=========================

//------------------------------------------------------------
//2019.STL 3.19 화9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// - 알고리즘 시간재기
// - 자원을 확보하는 클래스를 만들어 놓기
// 구분자를 넣어도 문법 오류가 아님!
//------------------------------------------------------------
#include "save.h"
#include <functional>
using namespace std;

void jump() {
	cout << "점프" << endl;//요건 함수다
}

void slide() {
	cout << "슬라이드" << endl;
}

class Dog {
public:
	void operator()() {
		cout << "CRAZY DOG" << endl;
	}
	void bark() {
		cout << "BITTEN!" << endl;
	}
};

int main()
{
	//void (*f1)(void) =jump; 이게 고전적인 방법.
	//cout << typeid(f1).name() << endl; 함수포인터라고 출력됨.

	//auto f2 = []() {cout << "람다" << endl; };//함수인데 이름이 없어요
	//cout << typeid(f2).name() << endl;//완전히 다른 타입이 튀어나온다.
	//함수는 언제나 전역함수로 선언해야 하지만,
	//람다는 지역에서 사용이 가능하다. []을 캡쳐라고 한다.
	//[]로 전역의 함수를 가져올 수 있다.
	
	//Dog d;
	//void (Dog::*f3)(void) = &Dog::operator();//void(Dog::*f3)(void)=&Dog::operator();
	//
	//cout << typeid(f3).name() << endl;

	//객체를 만들어 보자.
	Dog* pd = new Dog;
	pd->bark();

	save("소스.cpp");
}

=========================
Tue Mar 19 17:42:19 2019
=========================

//------------------------------------------------------------
//2019.STL 3.19 화9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// - 알고리즘 시간재기
// - 자원을 확보하는 클래스를 만들어 놓기
// 구분자를 넣어도 문법 오류가 아님!
//------------------------------------------------------------
#include "save.h"
#include <functional>
using namespace std;

void jump() {
	cout << "점프" << endl;//요건 함수다
}

void slide() {
	cout << "슬라이드" << endl;
}

class Dog {
public:
	void operator()() {
		cout << "CRAZY DOG" << endl;
	}
	void bark() {
		cout << "BITTEN!" << endl;
	}
};

int main()
{
	//void (*f1)(void) =jump; 이게 고전적인 방법.
	//cout << typeid(f1).name() << endl; 함수포인터라고 출력됨.

	//auto f2 = []() {cout << "람다" << endl; };//함수인데 이름이 없어요
	//cout << typeid(f2).name() << endl;//완전히 다른 타입이 튀어나온다.
	//함수는 언제나 전역함수로 선언해야 하지만,
	//람다는 지역에서 사용이 가능하다. []을 캡쳐라고 한다.
	//[]로 전역의 함수를 가져올 수 있다.
	
	//Dog d;
	//void (Dog::*f3)(void) = &Dog::operator();//void(Dog::*f3)(void)=&Dog::operator();
	//호출시 (d.*f3)();
	//cout << typeid(f3).name() << endl;

	//객체를 만들어 보자.
	Dog* pd = new Dog;
	auto f4 = &Dog::bark;
	//호출
	(pd->*f4)();
	cout << typeid(f4).name() << endl;

	save("소스.cpp");
}

=========================
Tue Mar 19 17:52:46 2019
=========================

//------------------------------------------------------------
//2019.STL 3.19 화9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// - 알고리즘 시간재기
// - 자원을 확보하는 클래스를 만들어 놓기
// 구분자를 넣어도 문법 오류가 아님!
//------------------------------------------------------------
#include "save.h"
#include <functional>
using namespace std;

void jump() {
	cout << "점프" << endl;//요건 함수다
}

void slide() {
	cout << "슬라이드" << endl;
}

class Dog {
public:
	void operator()() {
		cout << "CRAZY DOG" << endl;
	}
	void bark() {
		cout << "BITTEN!" << endl;
	}
};

int main()
{
	//void (*f1)(void) =jump; 이게 고전적인 방법.
	//cout << typeid(f1).name() << endl; 함수포인터라고 출력됨.

	//auto f2 = []() {cout << "람다" << endl; };//함수인데 이름이 없어요
	//cout << typeid(f2).name() << endl;//완전히 다른 타입이 튀어나온다.
	//함수는 언제나 전역함수로 선언해야 하지만,
	//람다는 지역에서 사용이 가능하다. []을 캡쳐라고 한다.
	//[]로 전역의 함수를 가져올 수 있다.
	
	//Dog d;
	//void (Dog::*f3)(void) = &Dog::operator();//void(Dog::*f3)(void)=&Dog::operator();
	//호출시 (d.*f3)();
	//cout << typeid(f3).name() << endl;

	////객체를 만들어 보자.
	//Dog* pd = new Dog;
	//auto f4 = &Dog::bark;
	////호출
	//(pd->*f4)();
	//cout << typeid(f4).name() << endl;

	//호출할 수 있는 함수는 무한하다.
	//하지만 굳이 이렇게 불편하게 하는 이유는 무엇일까?
	//다른 함수에 인자를 넘겨주기 위해서 이다.
	//이럴때에는 functional을 이용한다.
	Dog a, b, c;

	

	function<void(void)> f1 = jump;
	cout << typeid(f1).name() << endl;

	function<void(void)>f2 = []() {};
	cout << typeid(f2).name() << endl;

	function<void(Dog* const)>f3 = &Dog::operator();
	cout << typeid(f3).name() << endl;

	function<void(Dog* const)>f4 = &Dog::bark;
	cout << typeid(f4).name() << endl;

	//객체가 함수를 불러온다면 누가 어떤객체인지 스스로 알려주기 때문에 알 수 있다.
	
	save("소스.cpp");
}

=========================
Tue Mar 19 18:22:25 2019
=========================

//------------------------------------------------------------
//2019.STL 3.19 화9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// - 알고리즘 시간재기
// - 자원을 확보하는 클래스를 만들어 놓기
// 구분자를 넣어도 문법 오류가 아님!
// 과제 - 책 1장을 읽어보기
//------------------------------------------------------------
#include "save.h"
#include <random>
using namespace std; 

//정수를 인자로 받아 그 숫자만큼(byte단위) HEAP에서 메모리를 확보한다.
//확보한 메모리를 임의의 소문자로 채워라 uid('a','z'),uid(dre)
//main()에서 요구하는 대로 실행되도록 하자.
uniform_int_distribution<> uid('a', 'z');
default_random_engine dre;

class String {
	int num;
	char *p;
public:
	String(int n) {
		p = new char[n];
		for (int i = 0; i < n; ++i)
			p[i] = uid(dre);
	}

	~String() {
		delete[] p;
	}

	friend ostream& operator<<(ostream&, const String&);
};

ostream& operator<<(ostream& os, const String& str)
{
	for (int i = 0; i < str.num; ++i)
		os << str.p[i];
	return os;
}

int main()
{
	
	String a{ 123 };//123개의 임의의 글자로 채운 123바이트 HEAP을 생성

	cout << a << endl;//화면에 123개 문자가 출력됨

	save("소스.cpp");
}

=========================
Tue Mar 19 18:22:56 2019
=========================

//------------------------------------------------------------
//2019.STL 3.19 화9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// - 알고리즘 시간재기
// - 자원을 확보하는 클래스를 만들어 놓기
// 구분자를 넣어도 문법 오류가 아님!
// 과제 - 책 1장을 읽어보기
//------------------------------------------------------------
#include "save.h"
#include <random>
using namespace std;

//정수를 인자로 받아 그 숫자만큼(byte단위) HEAP에서 메모리를 확보한다.
//확보한 메모리를 임의의 소문자로 채워라 uid('a','z'),uid(dre)
//main()에서 요구하는 대로 실행되도록 하자.
uniform_int_distribution<> uid('a', 'z');
default_random_engine dre;

class String {
	int num;
	char *p;
public:
	String(int n) :num{ n } {
		p = new char[n];
		for (int i = 0; i < n; ++i)
			p[i] = uid(dre);
	}

	~String() {
		delete[] p;
	}

	friend ostream& operator<<(ostream&, const String&);
};

ostream& operator<<(ostream& os, const String& str)
{
	for (int i = 0; i < str.num; ++i)
		os << str.p[i];
	return os;
}

int main()
{

	String a{ 123 };//123개의 임의의 글자로 채운 123바이트 HEAP을 생성

	cout << a << endl;//화면에 123개 문자가 출력됨

	save("소스.cpp");
}

=========================
Tue Mar 19 18:30:52 2019
=========================

//------------------------------------------------------------
//2019.STL 3.19 화9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// - 알고리즘 시간재기
// - 자원을 확보하는 클래스를 만들어 놓기
// 구분자를 넣어도 문법 오류가 아님!
// 과제 - 책 1장을 읽어보기
//------------------------------------------------------------
#include "save.h"
#include <random>
using namespace std;

//정수를 인자로 받아 그 숫자만큼(byte단위) HEAP에서 메모리를 확보한다.
//확보한 메모리를 임의의 소문자로 채워라 uid('a','z'),uid(dre)
//main()에서 요구하는 대로 실행되도록 하자.
uniform_int_distribution<> uid('a', 'z');
default_random_engine dre;

//클래스가 자원을 확보한다면
//1. 생성자에서 new로 자원을 확보
//2. 소멸자에서 자원을 delete하기
//3. 복사생성자에서 깊은 복사
//4. 할당연산자에서 깊은 복사


class String {
	int num;
	char *p;
public:
	String(int n) :num{ n } {
		p = new char[num];
		for (int i = 0; i < num; ++i)
			p[i] = uid(dre);
	}

	~String() {
		delete[] p;
	}
	
	String(const String& other) :num{ other.num } {
		p = new char[num];
		memcpy(p, other.p, num);
	}

	String& operator=(const String& other) {
		if (this == &other)
			return *this;
		delete[] p;
		num = other.num;
		p = new char[num];
		memcpy(p, other.p, num);
		return *this;
	}

	friend ostream& operator<<(ostream&, const String&);
};

//복사생성자를 잊어버리지 말자!

ostream& operator<<(ostream& os, const String& str)
{
	for (int i = 0; i < str.num; ++i)
		os << str.p[i];
	return os;
}

int main()
{

	String a{ 10 };
	String b{ 12 };

	cout << a << endl;
	cout << b << endl;

	a = b;

	cout << a << endl;
	cout << b << endl;

	save("소스.cpp");
}

=========================
Tue Mar 19 18:31:28 2019
=========================

//------------------------------------------------------------
//2019.STL 3.19 화9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// - 알고리즘 시간재기
// - 자원을 확보하는 클래스를 만들어 놓기
// 구분자를 넣어도 문법 오류가 아님!
// 과제 - 책 1장을 읽어보기
//------------------------------------------------------------
#include "save.h"
#include <random>
using namespace std;

//정수를 인자로 받아 그 숫자만큼(byte단위) HEAP에서 메모리를 확보한다.
//확보한 메모리를 임의의 소문자로 채워라 uid('a','z'),uid(dre)
//main()에서 요구하는 대로 실행되도록 하자.
uniform_int_distribution<> uid('a', 'z');
default_random_engine dre;

//클래스가 자원을 확보한다면
//1. 생성자에서 new로 자원을 확보
//2. 소멸자에서 자원을 delete하기
//3. 복사생성자에서 깊은 복사
//4. 할당연산자에서 깊은 복사


class String {
	int num;
	char *p;
public:
	String(int n) :num{ n } {
		p = new char[num];
		for (int i = 0; i < num; ++i)
			p[i] = uid(dre);
	}

	~String() {
		delete[] p;
	}
	
	String(const String& other) :num{ other.num } {
		p = new char[num];
		memcpy(p, other.p, num);
	}

	String& operator=(const String& other) {
		if (this == &other)
			return *this;
		delete[] p;
		num = other.num;
		p = new char[num];
		memcpy(p, other.p, num);
		return *this;
	}

	friend ostream& operator<<(ostream&, const String&);
};

//복사생성자를 잊어버리지 말자!

ostream& operator<<(ostream& os, const String& str)
{
	for (int i = 0; i < str.num; ++i)
		os << str.p[i];
	return os;
}

int main()
{

	String a{ 10123 };
	String b{ 12444 };

	cout << a << endl;
	cout << b << endl;

	a = b;

	cout << a << endl;
	cout << b << endl;

	save("소스.cpp");
}

=========================
Tue Mar 19 18:36:58 2019
=========================

//------------------------------------------------------------
//2019.STL 3.19 화9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// - 알고리즘 시간재기
// - 자원을 확보하는 클래스를 만들어 놓기
// 구분자를 넣어도 문법 오류가 아님!
// 과제 - 책 1장을 읽어보기
//------------------------------------------------------------
#include "save.h"
#include <random>
using namespace std;

//정수를 인자로 받아 그 숫자만큼(byte단위) HEAP에서 메모리를 확보한다.
//확보한 메모리를 임의의 소문자로 채워라 uid('a','z'),uid(dre)
//main()에서 요구하는 대로 실행되도록 하자.
uniform_int_distribution<> uid('a', 'z');
default_random_engine dre;

//클래스가 자원을 확보한다면
//1. 생성자에서 new로 자원을 확보
//2. 소멸자에서 자원을 delete하기
//3. 복사생성자에서 깊은 복사
//4. 할당연산자에서 깊은 복사


class String {
	int num;
	char *p;
public:
	String(int n) :num{ n } {
		p = new char[num];
		for (int i = 0; i < num; ++i)
			p[i] = uid(dre);
	}

	~String() {
		delete[] p;
	}
	
	String(const String& other) :num{ other.num } {
		p = new char[num];
		memcpy(p, other.p, num);
	}

	String& operator=(const String& other) {
		if (this == &other)
			return *this;
		delete[] p;
		num = other.num;
		p = new char[num];
		memcpy(p, other.p, num);
		return *this;
	}

	friend ostream& operator<<(ostream&, const String&);
};

//복사생성자를 잊어버리지 말자!

ostream& operator<<(ostream& os, const String& str)
{
	for (int i = 0; i < str.num; ++i)
		os << str.p[i];
	return os;
}

int main()
{

	String a{ 20 };
	String b = a;

	cout << a << endl;
	cout << b << endl;

	save("소스.cpp");
}

=========================
Tue Mar 19 18:44:26 2019
=========================

//------------------------------------------------------------
//2019.STL 3.19 화9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// - 알고리즘 시간재기
// - 자원을 확보하는 클래스를 만들어 놓기
// 구분자를 넣어도 문법 오류가 아님!
// 과제 - 책 1장을 읽어보기
//------------------------------------------------------------
#include "save.h"
#include <random>
using namespace std;

//정수를 인자로 받아 그 숫자만큼(byte단위) HEAP에서 메모리를 확보한다.
//확보한 메모리를 임의의 소문자로 채워라 uid('a','z'),uid(dre)
//main()에서 요구하는 대로 실행되도록 하자.
uniform_int_distribution<> uid('a', 'z');
default_random_engine dre;

//클래스가 자원을 확보한다면
//1. 생성자에서 new로 자원을 확보
//2. 소멸자에서 자원을 delete하기
//3. 복사생성자에서 깊은 복사
//4. 할당연산자에서 깊은 복사

//C++11의 이동의미론(move semantics)을 구현하려면
//5. 이동생성자를 만든다
//6. 이동할당연산자를 만든다

class String {
	int num;
	char *p;
public:
	String(int n) :num{ n } {
		p = new char[num];
		for (int i = 0; i < num; ++i)
			p[i] = uid(dre);
	}

	~String() {
		delete[] p;
	}
	
	String(const String& other) :num{ other.num } {
		p = new char[num];
		memcpy(p, other.p, num);
	}

	String& operator=(const String& other) {
		if (this == &other)
			return *this;
		delete[] p;
		num = other.num;
		p = new char[num];
		memcpy(p, other.p, num);
		return *this;
	}

	friend ostream& operator<<(ostream&, const String&);
};

//복사생성자를 잊어버리지 말자!

ostream& operator<<(ostream& os, const String& str)
{
	for (int i = 0; i < str.num; ++i)
		os << str.p[i];
	return os;
}

int main()
{

	String a{ 20 };
	String b = move(a);

	//move가 뭔지??
	//이동생성자가 존재하지 않는 다면 복사생성을 한다.
	//이것의 역할은 b가 a를 가리키게 하고 a의 값은 삭제한다.

	cout << a << endl;
	cout << b << endl;

	save("소스.cpp");
}

=========================
Thu Mar 21 17:35:10 2019
=========================

//------------------------------------------------------------
//2019.STL 3.19 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// - 알고리즘 시간재기
// - 자원을 확보하는 클래스를 만들어 놓기
// 구분자를 넣어도 문법 오류가 아님!
// 과제 - 책 1장을 읽어보기
// class String을 #include "String.h"로 분리해보자
//------------------------------------------------------------
#include "save.h"
#include <random>
using namespace std;

//정수를 인자로 받아 그 숫자만큼(byte단위) HEAP에서 메모리를 확보한다.
//확보한 메모리를 임의의 소문자로 채워라 uid('a','z'),uid(dre)
//main()에서 요구하는 대로 실행되도록 하자.
uniform_int_distribution<> uid('a', 'z');
uniform_int_distribution<> uidobj(1, 80);
default_random_engine dre;

//클래스가 자원을 확보한다면
//1. 생성자에서 new로 자원을 확보
//2. 소멸자에서 자원을 delete하기
//3. 복사생성자에서 깊은 복사
//4. 할당연산자에서 깊은 복사

//C++11의 이동의미론(move semantics)을 구현하려면
//5. 이동생성자를 만든다
//6. 이동할당연산자를 만든다

class String {
	int num{ 0 };
	char *p{ nullptr };
public:
	String() = default;

	String(int n) :num{ n } {
		p = new char[num];
		for (int i = 0; i < num; ++i)
			p[i] = uid(dre);
	}

	~String() {
		delete[] p;
	}
	
	String(const String& other) :num{ other.num } {
		p = new char[num];
		memcpy(p, other.p, num);
	}

	String& operator=(const String& other) {
		if (this == &other)
			return *this;
		delete[] p;
		num = other.num;
		p = new char[num];
		memcpy(p, other.p, num);
		return *this;
	}

	void set(int n) {
		num = n;
		if (p == nullptr)
			delete[] p;

		p = new char[num];
	}

	friend ostream& operator<<(ostream&, const String&);
};

//복사생성자를 잊어버리지 말자!

ostream& operator<<(ostream& os, const String& str)
{
	for (int i = 0; i < str.num; ++i)
		os << str.p[i];
	return os;
}

//100개의 string을 임의의 갯수로 ( 1, 80 )로 설정하라.
//strings의 num오름차순으로 정렬하라.
//	for(String d:strings)
//		cout << d << endl;

int main()
{
	String strings[100];

	for (String& d : strings)
		d.set(uidobj(dre));

	for (String d : strings)
		cout << d << endl;

	save("소스.cpp");
}

=========================
Thu Mar 21 17:43:08 2019
=========================

//------------------------------------------------------------
//2019.STL 3.19 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// - 알고리즘 시간재기
// - 자원을 확보하는 클래스를 만들어 놓기
// 구분자를 넣어도 문법 오류가 아님!
// 과제 - 책 1장을 읽어보기
// class String을 #include "String.h"로 분리해보자
//------------------------------------------------------------
#include "save.h"
#include <random>
using namespace std;

//정수를 인자로 받아 그 숫자만큼(byte단위) HEAP에서 메모리를 확보한다.
//확보한 메모리를 임의의 소문자로 채워라 uid('a','z'),uid(dre)
//main()에서 요구하는 대로 실행되도록 하자.
uniform_int_distribution<> uid('a', 'z');
uniform_int_distribution<> uidobj(1, 80);
default_random_engine dre;

//클래스가 자원을 확보한다면
//1. 생성자에서 new로 자원을 확보
//2. 소멸자에서 자원을 delete하기
//3. 복사생성자에서 깊은 복사
//4. 할당연산자에서 깊은 복사

//C++11의 이동의미론(move semantics)을 구현하려면
//5. 이동생성자를 만든다
//6. 이동할당연산자를 만든다

class String {
	int num{ 0 };
	char *p{ nullptr };
public:
	String() = default;

	String(int n) :num{ n } {
		p = new char[num];
		for (int i = 0; i < num; ++i)
			p[i] = uid(dre);
	}

	~String() {
		delete[] p;
	}
	
	String(const String& other) :num{ other.num } {
		p = new char[num];
		memcpy(p, other.p, num);
	}

	String& operator=(const String& other) {
		if (this == &other)
			return *this;
		delete[] p;
		num = other.num;
		p = new char[num];
		memcpy(p, other.p, num);
		return *this;
	}

	void set(int n) {
		num = n;
		if (p == nullptr)
			delete[] p;

		p = new char[num];
		for (int i = 0; i < num; ++i)
			p[i] = uid(dre);
	}

	int get() {
		return num;
	}

	friend ostream& operator<<(ostream&, const String&);
};

//복사생성자를 잊어버리지 말자!

ostream& operator<<(ostream& os, const String& str)
{
	for (int i = 0; i < str.num; ++i)
		os << str.p[i];
	return os;
}

//100개의 string을 임의의 갯수로 ( 1, 80 )로 설정하라.
//strings의 num오름차순으로 정렬하라.
//	for(String d:strings)
//		cout << d << endl;

int main()
{
	String strings[100];

	for (String& d : strings)
		d.set(uidobj(dre));

	sort(begin(strings), end(strings), [](String a, String b) {
		return a.get() < b.get();
	});

	for (String d : strings)
		cout << d << endl;

	save("소스.cpp");
}

=========================
Thu Mar 21 17:43:35 2019
=========================

//------------------------------------------------------------
//2019.STL 3.19 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// - 알고리즘 시간재기
// - 자원을 확보하는 클래스를 만들어 놓기
// 구분자를 넣어도 문법 오류가 아님!
// 과제 - 책 1장을 읽어보기
// class String을 #include "String.h"로 분리해보자
//------------------------------------------------------------
#include "save.h"
#include <random>
using namespace std;

//정수를 인자로 받아 그 숫자만큼(byte단위) HEAP에서 메모리를 확보한다.
//확보한 메모리를 임의의 소문자로 채워라 uid('a','z'),uid(dre)
//main()에서 요구하는 대로 실행되도록 하자.
uniform_int_distribution<> uid('a', 'z');
uniform_int_distribution<> uidobj(1, 80);
default_random_engine dre;

//클래스가 자원을 확보한다면
//1. 생성자에서 new로 자원을 확보
//2. 소멸자에서 자원을 delete하기
//3. 복사생성자에서 깊은 복사
//4. 할당연산자에서 깊은 복사

//C++11의 이동의미론(move semantics)을 구현하려면
//5. 이동생성자를 만든다
//6. 이동할당연산자를 만든다

class String {
	int num{ 0 };
	char *p{ nullptr };
public:
	String() = default;

	String(int n) :num{ n } {
		p = new char[num];
		for (int i = 0; i < num; ++i)
			p[i] = uid(dre);
	}

	~String() {
		delete[] p;
	}
	
	String(const String& other) :num{ other.num } {
		p = new char[num];
		memcpy(p, other.p, num);
	}

	String& operator=(const String& other) {
		if (this == &other)
			return *this;
		delete[] p;
		num = other.num;
		p = new char[num];
		memcpy(p, other.p, num);
		return *this;
	}

	void set(int n) {
		num = n;
		if (p == nullptr)
			delete[] p;

		p = new char[num];
		for (int i = 0; i < num; ++i)
			p[i] = uid(dre);
	}

	int get() {
		return num;
	}

	friend ostream& operator<<(ostream&, const String&);
};

//복사생성자를 잊어버리지 말자!

ostream& operator<<(ostream& os, const String& str)
{
	for (int i = 0; i < str.num; ++i)
		os << str.p[i];
	return os;
}

//100개의 string을 임의의 갯수로 ( 1, 80 )로 설정하라.
//strings의 num오름차순으로 정렬하라.
//	for(String d:strings)
//		cout << d << endl;

int main()
{
	String strings[100];

	for (String& d : strings)
		d.set(uidobj(dre));

	sort(begin(strings), end(strings), [](String a, String b) {
		return a.get() < b.get();
	});

	for (String d : strings)
		cout << d << endl;

	save("소스.cpp");
}

=========================
Thu Mar 21 17:43:38 2019
=========================

//------------------------------------------------------------
//2019.STL 3.19 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// - 알고리즘 시간재기
// - 자원을 확보하는 클래스를 만들어 놓기
// 구분자를 넣어도 문법 오류가 아님!
// 과제 - 책 1장을 읽어보기
// class String을 #include "String.h"로 분리해보자
//------------------------------------------------------------
#include "save.h"
#include <random>
using namespace std;

//정수를 인자로 받아 그 숫자만큼(byte단위) HEAP에서 메모리를 확보한다.
//확보한 메모리를 임의의 소문자로 채워라 uid('a','z'),uid(dre)
//main()에서 요구하는 대로 실행되도록 하자.
uniform_int_distribution<> uid('a', 'z');
uniform_int_distribution<> uidobj(1, 80);
default_random_engine dre;

//클래스가 자원을 확보한다면
//1. 생성자에서 new로 자원을 확보
//2. 소멸자에서 자원을 delete하기
//3. 복사생성자에서 깊은 복사
//4. 할당연산자에서 깊은 복사

//C++11의 이동의미론(move semantics)을 구현하려면
//5. 이동생성자를 만든다
//6. 이동할당연산자를 만든다

class String {
	int num{ 0 };
	char *p{ nullptr };
public:
	String() = default;

	String(int n) :num{ n } {
		p = new char[num];
		for (int i = 0; i < num; ++i)
			p[i] = uid(dre);
	}

	~String() {
		delete[] p;
	}
	
	String(const String& other) :num{ other.num } {
		p = new char[num];
		memcpy(p, other.p, num);
	}

	String& operator=(const String& other) {
		if (this == &other)
			return *this;
		delete[] p;
		num = other.num;
		p = new char[num];
		memcpy(p, other.p, num);
		return *this;
	}

	void set(int n) {
		num = n;
		if (p == nullptr)
			delete[] p;

		p = new char[num];
		for (int i = 0; i < num; ++i)
			p[i] = uid(dre);
	}

	int get() {
		return num;
	}

	friend ostream& operator<<(ostream&, const String&);
};

//복사생성자를 잊어버리지 말자!

ostream& operator<<(ostream& os, const String& str)
{
	for (int i = 0; i < str.num; ++i)
		os << str.p[i];
	return os;
}

//100개의 string을 임의의 갯수로 ( 1, 80 )로 설정하라.
//strings의 num오름차순으로 정렬하라.
//	for(String d:strings)
//		cout << d << endl;

int main()
{
	String strings[100];

	for (String& d : strings)
		d.set(uidobj(dre));

	sort(begin(strings), end(strings), [](String a, String b) {
		return a.get() < b.get();
	});

	for (String d : strings)
		cout << d << endl;

	save("소스.cpp");
}

=========================
Thu Mar 21 17:43:44 2019
=========================

//------------------------------------------------------------
//2019.STL 3.19 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// - 알고리즘 시간재기
// - 자원을 확보하는 클래스를 만들어 놓기
// 구분자를 넣어도 문법 오류가 아님!
// 과제 - 책 1장을 읽어보기
// class String을 #include "String.h"로 분리해보자
//------------------------------------------------------------
#include "save.h"
#include <random>
using namespace std;

//정수를 인자로 받아 그 숫자만큼(byte단위) HEAP에서 메모리를 확보한다.
//확보한 메모리를 임의의 소문자로 채워라 uid('a','z'),uid(dre)
//main()에서 요구하는 대로 실행되도록 하자.
uniform_int_distribution<> uid('a', 'z');
uniform_int_distribution<> uidobj(1, 80);
default_random_engine dre;

//클래스가 자원을 확보한다면
//1. 생성자에서 new로 자원을 확보
//2. 소멸자에서 자원을 delete하기
//3. 복사생성자에서 깊은 복사
//4. 할당연산자에서 깊은 복사

//C++11의 이동의미론(move semantics)을 구현하려면
//5. 이동생성자를 만든다
//6. 이동할당연산자를 만든다

class String {
	int num{ 0 };
	char *p{ nullptr };
public:
	String() = default;

	String(int n) :num{ n } {
		p = new char[num];
		for (int i = 0; i < num; ++i)
			p[i] = uid(dre);
	}

	~String() {
		delete[] p;
	}
	
	String(const String& other) :num{ other.num } {
		p = new char[num];
		memcpy(p, other.p, num);
	}

	String& operator=(const String& other) {
		if (this == &other)
			return *this;
		delete[] p;
		num = other.num;
		p = new char[num];
		memcpy(p, other.p, num);
		return *this;
	}

	void set(int n) {
		num = n;
		if (p == nullptr)
			delete[] p;

		p = new char[num];
		for (int i = 0; i < num; ++i)
			p[i] = uid(dre);
	}

	int get() {
		return num;
	}

	friend ostream& operator<<(ostream&, const String&);
};

//복사생성자를 잊어버리지 말자!

ostream& operator<<(ostream& os, const String& str)
{
	for (int i = 0; i < str.num; ++i)
		os << str.p[i];
	return os;
}

//100개의 string을 임의의 갯수로 ( 1, 80 )로 설정하라.
//strings의 num오름차순으로 정렬하라.
//	for(String d:strings)
//		cout << d << endl;

int main()
{
	String strings[100];

	for (String& d : strings)
		d.set(uidobj(dre));

	sort(begin(strings), end(strings), [](String a, String b) {
		return a.get() < b.get();
	});

	for (String d : strings)
		cout << d << endl;

	save("소스.cpp");
}

=========================
Thu Mar 21 17:44:08 2019
=========================

//------------------------------------------------------------
//2019.STL 3.19 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// - 알고리즘 시간재기
// - 자원을 확보하는 클래스를 만들어 놓기
// 구분자를 넣어도 문법 오류가 아님!
// 과제 - 책 1장을 읽어보기
// class String을 #include "String.h"로 분리해보자
//------------------------------------------------------------
#include "save.h"
#include <random>
using namespace std;

//정수를 인자로 받아 그 숫자만큼(byte단위) HEAP에서 메모리를 확보한다.
//확보한 메모리를 임의의 소문자로 채워라 uid('a','z'),uid(dre)
//main()에서 요구하는 대로 실행되도록 하자.
uniform_int_distribution<> uid('a', 'z');
uniform_int_distribution<> uidobj(1, 80);
default_random_engine dre;

//클래스가 자원을 확보한다면
//1. 생성자에서 new로 자원을 확보
//2. 소멸자에서 자원을 delete하기
//3. 복사생성자에서 깊은 복사
//4. 할당연산자에서 깊은 복사

//C++11의 이동의미론(move semantics)을 구현하려면
//5. 이동생성자를 만든다
//6. 이동할당연산자를 만든다

class String {
	int num{ 0 };
	char *p{ nullptr };
public:
	String() = default;

	String(int n) :num{ n } {
		p = new char[num];
		for (int i = 0; i < num; ++i)
			p[i] = uid(dre);
	}

	~String() {
		delete[] p;
	}
	
	String(const String& other) :num{ other.num } {
		p = new char[num];
		memcpy(p, other.p, num);
	}

	String& operator=(const String& other) {
		if (this == &other)
			return *this;
		delete[] p;
		num = other.num;
		p = new char[num];
		memcpy(p, other.p, num);
		return *this;
	}

	void set(int n) {
		num = n;
		if (p == nullptr)
			delete[] p;

		p = new char[num];
		for (int i = 0; i < num; ++i)
			p[i] = uid(dre);
	}

	int get() {
		return num;
	}

	friend ostream& operator<<(ostream&, const String&);
};

//복사생성자를 잊어버리지 말자!

ostream& operator<<(ostream& os, const String& str)
{
	for (int i = 0; i < str.num; ++i)
		os << str.p[i];
	return os;
}

//100개의 string을 임의의 갯수로 ( 1, 80 )로 설정하라.
//strings의 num오름차순으로 정렬하라.
//	for(String d:strings)
//		cout << d << endl;

int main()
{
	String strings[100];

	for (String& d : strings)
		d.set(uidobj(dre));

	sort(begin(strings), end(strings), [](String a, String b) {
		return a.get() < b.get();
	});

	for (String d : strings)
		cout << d << endl;

	save("소스.cpp");
}

=========================
Thu Mar 21 17:45:01 2019
=========================

//------------------------------------------------------------
//2019.STL 3.19 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// - 알고리즘 시간재기
// - 자원을 확보하는 클래스를 만들어 놓기
// 구분자를 넣어도 문법 오류가 아님!
// 과제 - 책 1장을 읽어보기
// class String을 #include "String.h"로 분리해보자
//------------------------------------------------------------
#include "save.h"
#include <random>
using namespace std;

//정수를 인자로 받아 그 숫자만큼(byte단위) HEAP에서 메모리를 확보한다.
//확보한 메모리를 임의의 소문자로 채워라 uid('a','z'),uid(dre)
//main()에서 요구하는 대로 실행되도록 하자.
uniform_int_distribution<> uid('a', 'z');
uniform_int_distribution<> uidobj(1, 80);
default_random_engine dre;

//클래스가 자원을 확보한다면
//1. 생성자에서 new로 자원을 확보
//2. 소멸자에서 자원을 delete하기
//3. 복사생성자에서 깊은 복사
//4. 할당연산자에서 깊은 복사

//C++11의 이동의미론(move semantics)을 구현하려면
//5. 이동생성자를 만든다
//6. 이동할당연산자를 만든다

class String {
	int num{ 0 };
	char *p{ nullptr };
public:
	String() = default;

	String(int n) :num{ n } {
		p = new char[num];
		for (int i = 0; i < num; ++i)
			p[i] = uid(dre);
	}

	~String() {
		delete[] p;
	}
	
	String(const String& other) :num{ other.num } {
		p = new char[num];
		memcpy(p, other.p, num);
	}

	String& operator=(const String& other) {
		if (this == &other)
			return *this;
		delete[] p;
		num = other.num;
		p = new char[num];
		memcpy(p, other.p, num);
		return *this;
	}

	void set(int n) {
		num = n;
		if (p == nullptr)
			delete[] p;

		p = new char[num];
		for (int i = 0; i < num; ++i)
			p[i] = uid(dre);
	}

	int get() {
		return num;
	}

	friend ostream& operator<<(ostream&, const String&);
};

//복사생성자를 잊어버리지 말자!

ostream& operator<<(ostream& os, const String& str)
{
	for (int i = 0; i < str.num; ++i)
		os << str.p[i];
	return os;
}

//100개의 string을 임의의 갯수로 ( 1, 80 )로 설정하라.
//strings의 num오름차순으로 정렬하라.
//	for(String d:strings)
//		cout << d << endl;

int main()
{
	String strings[1000];

	for (String& d : strings)
		d.set(uidobj(dre));

	sort(begin(strings), end(strings), [](String a, String b) {
		return a.get() < b.get();
	});

	for (String d : strings)
		cout << d << endl;

	save("소스.cpp");
}

=========================
Thu Mar 21 17:45:37 2019
=========================

//------------------------------------------------------------
//2019.STL 3.19 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// - 알고리즘 시간재기
// - 자원을 확보하는 클래스를 만들어 놓기
// 구분자를 넣어도 문법 오류가 아님!
// 과제 - 책 1장을 읽어보기
// class String을 #include "String.h"로 분리해보자
//------------------------------------------------------------
#include "save.h"
#include <random>
using namespace std;

//정수를 인자로 받아 그 숫자만큼(byte단위) HEAP에서 메모리를 확보한다.
//확보한 메모리를 임의의 소문자로 채워라 uid('a','z'),uid(dre)
//main()에서 요구하는 대로 실행되도록 하자.
uniform_int_distribution<> uid('a', 'z');
uniform_int_distribution<> uidobj(1, 80);
default_random_engine dre;

//클래스가 자원을 확보한다면
//1. 생성자에서 new로 자원을 확보
//2. 소멸자에서 자원을 delete하기
//3. 복사생성자에서 깊은 복사
//4. 할당연산자에서 깊은 복사

//C++11의 이동의미론(move semantics)을 구현하려면
//5. 이동생성자를 만든다
//6. 이동할당연산자를 만든다

class String {
	int num{ 0 };
	char *p{ nullptr };
public:
	String() = default;

	String(int n) :num{ n } {
		p = new char[num];
		for (int i = 0; i < num; ++i)
			p[i] = uid(dre);
	}

	~String() {
		delete[] p;
	}
	
	String(const String& other) :num{ other.num } {
		p = new char[num];
		memcpy(p, other.p, num);
	}

	String& operator=(const String& other) {
		if (this == &other)
			return *this;
		delete[] p;
		num = other.num;
		p = new char[num];
		memcpy(p, other.p, num);
		return *this;
	}

	void set(int n) {
		num = n;
		if (p == nullptr)
			delete[] p;

		p = new char[num];
		for (int i = 0; i < num; ++i)
			p[i] = uid(dre);
	}

	int get() {
		return num;
	}

	friend ostream& operator<<(ostream&, const String&);
};

//복사생성자를 잊어버리지 말자!

ostream& operator<<(ostream& os, const String& str)
{
	for (int i = 0; i < str.num; ++i)
		os << str.p[i];
	return os;
}

//100개의 string을 임의의 갯수로 ( 1, 80 )로 설정하라.
//strings의 num오름차순으로 정렬하라.
//	for(String d:strings)
//		cout << d << endl;

int main()
{
	String strings[10000];

	for (String& d : strings)
		d.set(uidobj(dre));

	sort(begin(strings), end(strings), [](String a, String b) {
		return a.get() < b.get();
	});

	for (String d : strings)
		cout << d << endl;

	save("소스.cpp");
}

=========================
Thu Mar 21 18:04:33 2019
=========================

//------------------------------------------------------------
//2019.STL 3.19 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// - 알고리즘 시간재기
// - 자원을 확보하는 클래스를 만들어 놓기
// 구분자를 넣어도 문법 오류가 아님!
// 과제 - 책 1장을 읽어보기
// class String을 #include "String.h"로 분리해보자
//------------------------------------------------------------
#include "save.h"
#include "String.h"
#include <memory>
using namespace std;


int main()
{
	unique_ptr<String> a(new String{ 20 });

	cout << *a << endl;

	save("소스.cpp");
}

=========================
Thu Mar 21 18:23:21 2019
=========================

//------------------------------------------------------------
//2019.STL 3.19 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// - 알고리즘 시간재기
// - 자원을 확보하는 클래스를 만들어 놓기
// 구분자를 넣어도 문법 오류가 아님!
// 과제 - 책 1장을 읽어보기
// class String을 #include "String.h"로 분리해보자
//------------------------------------------------------------
#include "save.h"
#include "String.h"
#include <memory>
using namespace std;

uniform_int_distribution<> uidObj(1, 80);

int main()
{
	unique_ptr<String> p[5];

	p[0] = make_unique<String>(10);
	p[1] = make_unique<String>(2);
	p[2] = make_unique<String>(5);
	p[3] = make_unique<String>(20);
	p[4] = make_unique<String>(14);

	for (auto& d : p)
		cout << *d << endl;

	save("소스.cpp");
}

=========================
Thu Mar 21 18:25:56 2019
=========================

//------------------------------------------------------------
//2019.STL 3.19 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// - 알고리즘 시간재기
// - 자원을 확보하는 클래스를 만들어 놓기
// 구분자를 넣어도 문법 오류가 아님!
// 과제 - 책 1장을 읽어보기
// class String을 #include "String.h"로 분리해보자
//------------------------------------------------------------
#include "save.h"
#include "String.h"
#include <memory>
using namespace std;

uniform_int_distribution<> uidObj(1, 80);

int main()
{
	unique_ptr<String> p[5];

	p[0] = make_unique<String>(10);
	p[1] = make_unique<String>(2);
	p[2] = make_unique<String>(5);
	p[3] = make_unique<String>(20);
	p[4] = make_unique<String>(14);

	sort(begin(p),end(p),[](const unique_ptr<String>& a,const unique_ptr<String>& b){
		return a->get() < b->get();
	});

	for (auto& d : p)
		cout << *d << endl;

	save("소스.cpp");
}

=========================
Thu Mar 21 18:26:13 2019
=========================

//------------------------------------------------------------
//2019.STL 3.19 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// - 알고리즘 시간재기
// - 자원을 확보하는 클래스를 만들어 놓기
// 구분자를 넣어도 문법 오류가 아님!
// 과제 - 책 1장을 읽어보기
// class String을 #include "String.h"로 분리해보자
//------------------------------------------------------------
#include "save.h"
#include "String.h"
#include <memory>
using namespace std;

uniform_int_distribution<> uidObj(1, 80);

int main()
{
	unique_ptr<String> p[5];

	p[0] = make_unique<String>(10);
	p[1] = make_unique<String>(2);
	p[2] = make_unique<String>(5);
	p[3] = make_unique<String>(20);
	p[4] = make_unique<String>(14);

	sort(begin(p),end(p),[](const unique_ptr<String>& a,const unique_ptr<String>& b){
		return a->get() < b->get();
	});

	for (auto& d : p)
		cout << *d << endl;

	save("소스.cpp");
}

=========================
Thu Mar 21 18:26:33 2019
=========================

//------------------------------------------------------------
//2019.STL 3.19 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// - 알고리즘 시간재기
// - 자원을 확보하는 클래스를 만들어 놓기
// 구분자를 넣어도 문법 오류가 아님!
// 과제 - 책 1장을 읽어보기
// class String을 #include "String.h"로 분리해보자
//------------------------------------------------------------
#include "save.h"
#include "String.h"
#include <memory>
using namespace std;

uniform_int_distribution<> uidObj(1, 80);

int main()
{
	unique_ptr<String> p[5];

	p[0] = make_unique<String>(10);
	p[1] = make_unique<String>(2);
	p[2] = make_unique<String>(5);
	p[3] = make_unique<String>(20);
	p[4] = make_unique<String>(14);

	sort(begin(p),end(p),[](const unique_ptr<String>& a,const unique_ptr<String>& b){
		return a.get() < b.get();
	});

	for (auto& d : p)
		cout << *d << endl;

	save("소스.cpp");
}

=========================
Thu Mar 21 18:27:08 2019
=========================

//------------------------------------------------------------
//2019.STL 3.19 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// - 알고리즘 시간재기
// - 자원을 확보하는 클래스를 만들어 놓기
// 구분자를 넣어도 문법 오류가 아님!
// 과제 - 책 1장을 읽어보기
// class String을 #include "String.h"로 분리해보자
//------------------------------------------------------------
#include "save.h"
#include "String.h"
#include <memory>
using namespace std;

uniform_int_distribution<> uidObj(1, 80);

int main()
{
	unique_ptr<String> p[5];

	p[0] = make_unique<String>(10);
	p[1] = make_unique<String>(2);
	p[2] = make_unique<String>(5);
	p[3] = make_unique<String>(20);
	p[4] = make_unique<String>(14);

	sort(begin(p),end(p),[](const unique_ptr<String>& a,const unique_ptr<String>& b){
		return a->get() < b->get();
	});

	for (auto& d : p)
		cout << *d << endl;

	save("소스.cpp");
}

=========================
Thu Mar 21 18:27:10 2019
=========================

//------------------------------------------------------------
//2019.STL 3.19 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// - 알고리즘 시간재기
// - 자원을 확보하는 클래스를 만들어 놓기
// 구분자를 넣어도 문법 오류가 아님!
// 과제 - 책 1장을 읽어보기
// class String을 #include "String.h"로 분리해보자
//------------------------------------------------------------
#include "save.h"
#include "String.h"
#include <memory>
using namespace std;

uniform_int_distribution<> uidObj(1, 80);

int main()
{
	unique_ptr<String> p[5];

	p[0] = make_unique<String>(10);
	p[1] = make_unique<String>(2);
	p[2] = make_unique<String>(5);
	p[3] = make_unique<String>(20);
	p[4] = make_unique<String>(14);

	sort(begin(p),end(p),[](const unique_ptr<String>& a,const unique_ptr<String>& b){
		return a->get() < b->get();
	});

	for (auto& d : p)
		cout << *d << endl;

	save("소스.cpp");
}

=========================
Thu Mar 21 18:28:04 2019
=========================

//------------------------------------------------------------
//2019.STL 3.19 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// - 알고리즘 시간재기
// - 자원을 확보하는 클래스를 만들어 놓기
// 구분자를 넣어도 문법 오류가 아님!
// 과제 - 책 1장을 읽어보기
// class String을 #include "String.h"로 분리해보자
//------------------------------------------------------------
#include "save.h"
#include "String.h"
#include <memory>
using namespace std;

uniform_int_distribution<> uidObj(1, 80);

int main()
{
	unique_ptr<String> s;
	cout << sizeof(s) << endl;

	shared_ptr<String> t;
	cout << sizeof(t) << endl;

	save("소스.cpp");
}

=========================
Thu Mar 21 18:29:13 2019
=========================

//------------------------------------------------------------
//2019.STL 3.19 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// - 알고리즘 시간재기
// - 자원을 확보하는 클래스를 만들어 놓기
// 구분자를 넣어도 문법 오류가 아님!
// 과제 - 책 1장을 읽어보기
// class String을 #include "String.h"로 분리해보자
//------------------------------------------------------------
#include "save.h"
#include "String.h"
#include <memory>
using namespace std;

uniform_int_distribution<> uidObj(1, 80);

int main()
{
	unique_ptr<String> s;
	cout << sizeof(s) << endl;

	shared_ptr<String> t;
	cout << sizeof(t) << endl;

	save("소스.cpp");
}

=========================
Thu Mar 21 18:31:28 2019
=========================

//------------------------------------------------------------
//2019.STL 3.19 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// 과제 - 책 1장을 읽어보기
// class String을 #include "String.h"로 분리해보자
//------------------------------------------------------------
#include "save.h"
#include "String.h"
#include <memory>
using namespace std;

uniform_int_distribution<> uidObj(1, 80);

int main()
{
	unique_ptr<String> s;
	cout << sizeof(s) << endl;

	shared_ptr<String> t; //귀중한 자원이 있다는데 쓰이는 일은 거의 없다고 한다.
	cout << sizeof(t) << endl;

	save("소스.cpp");
}

=========================
Thu Mar 21 18:32:06 2019
=========================

//------------------------------------------------------------
//2019.STL 3.19 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// 과제 - 책 1장을 읽어보기
// class String을 #include "String.h"로 분리해보자
//------------------------------------------------------------
#include "save.h"
#include "String.h"
#include <memory>
using namespace std;

uniform_int_distribution<> uidObj(1, 80);

int main()
{
	unique_ptr<String> s;
	cout << sizeof(s) << endl;

	shared_ptr<String> t; //귀중한 자원이 있다는데 쓰이는 일은 거의 없다고 한다.
	cout << sizeof(t) << endl;

	cout << sizeof(char *) << endl;
	cout << sizeof(int) << endl;

	save("소스.cpp");
}

=========================
Thu Mar 21 18:49:37 2019
=========================

//------------------------------------------------------------
//2019.STL 3.19 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// 과제 - 책 1장을 읽어보기
// class String을 #include "String.h"로 분리해보자
//------------------------------------------------------------
#include "save.h"
#include "String.h"
#include <memory>
using namespace std;

// std::string 객체로 된 배열을 정의하고, 자신이 선택한 단어들로
// 초기화한 후에 반복자를 사용해 배열의 내용을 한줄에 하나씩 출력하는 프로그램


//STL은 속도를 우선한다
int main()
{
	string rts[5]{ "pigeon","seaguel","sparrow","crow","swallow" };

	//반복자를 사용하라.

	auto beg = begin(rts);
	cout << *beg << endl;
	++beg;
	cout << *beg << endl;

	save("소스.cpp");
}

=========================
Thu Mar 21 18:50:21 2019
=========================

//------------------------------------------------------------
//2019.STL 3.19 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// 과제 - 책 1장을 읽어보기
// class String을 #include "String.h"로 분리해보자
//------------------------------------------------------------
#include "save.h"
#include "String.h"
#include <memory>
using namespace std;

// std::string 객체로 된 배열을 정의하고, 자신이 선택한 단어들로
// 초기화한 후에 반복자를 사용해 배열의 내용을 한줄에 하나씩 출력하는 프로그램


//STL은 속도를 우선한다
int main()
{
	string rts[5]{ "pigeon","seaguel","sparrow","crow","swallow" };

	//반복자를 사용하라.

	for (auto beg = begin(rts); beg != end(rts); ++beg)
	{
		cout << *beg << endl;
	}

	save("소스.cpp");
}

=========================
Thu Mar 21 18:51:39 2019
=========================

//------------------------------------------------------------
//2019.STL 3.19 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// 과제 - 책 1장을 읽어보기
// class String을 #include "String.h"로 분리해보자
//------------------------------------------------------------
#include "save.h"
#include "String.h"
#include <memory>
#include <list>
using namespace std;

// std::string 객체로 된 배열을 정의하고, 자신이 선택한 단어들로
// 초기화한 후에 반복자를 사용해 배열의 내용을 한줄에 하나씩 출력하는 프로그램


//STL은 속도를 우선한다
int main()
{
	list<string> rts{ "pigeon","seaguel","sparrow","crow","swallow" };

	//반복자를 사용하라.

	for (auto beg = begin(rts); beg != end(rts); ++beg)
	{
		cout << *beg << endl;
	}

	save("소스.cpp");
}

=========================
Tue Mar 26 17:51:39 2019
=========================

//------------------------------------------------------------
//2019.STL 3.19 화9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// 과제 - 책 1장을 읽어보기
// class String을 #include "String.h"로 분리해보자
//------------------------------------------------------------
#include "save.h"
#include "String.h"
#include <memory>
#include <list>
#include <iterator>
using namespace std;

//STL은 속도를 우선한다
int main()
{
	list<string> rts{ "pigeon","seaguel","sparrow","crow","swallow" };

	//반복자를 사용하라.

	transform(begin(rts), end(rts),
		ostream_iterator<string>(cout, "\n"),
		[](string& rts) {
		/*for (char& d : rts) {
			if (d == 'a' || d == 'i' || d == 'e' || d == 'o' || d == 'u')
				d = '*';
			}*/
		for (auto i = begin(rts); i != end(rts); ++i)
			if (*i == 'a', *i == 'e', *i == 'i', *i == 'o', *i == 'u')
				*i = '*';
		return rts;
		});

	save("소스.cpp");
}

=========================
Tue Mar 26 17:52:10 2019
=========================

//------------------------------------------------------------
//2019.STL 3.19 화9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// 과제 - 책 1장을 읽어보기
// class String을 #include "String.h"로 분리해보자
//------------------------------------------------------------
#include "save.h"
#include "String.h"
#include <memory>
#include <list>
#include <iterator>
using namespace std;

//STL은 속도를 우선한다
int main()
{
	list<string> rts{ "pigeon","seaguel","sparrow","crow","swallow" };

	//반복자를 사용하라.

	transform(begin(rts), end(rts),
		ostream_iterator<string>(cout, "\n"),
		[](string& rts) {
		/*for (char& d : rts) {
			if (d == 'a' || d == 'i' || d == 'e' || d == 'o' || d == 'u')
				d = '*';
			}*/
		for (auto i = begin(rts); i != end(rts); ++i)
			if (*i == 'a'|| *i == 'e'|| *i == 'i'|| *i == 'o'|| *i == 'u')
				*i = '*';
		return rts;
		});

	save("소스.cpp");
}

=========================
Tue Mar 26 17:54:13 2019
=========================

//------------------------------------------------------------
//2019.STL 3.19 화9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// 과제 - 책 1장을 읽어보기
// class String을 #include "String.h"로 분리해보자
//------------------------------------------------------------
#include "save.h"
#include "String.h"
#include <memory>
#include <list>
#include <iterator>
using namespace std;

//STL은 속도를 우선한다
int main()
{
	list<string> rts{ "pigeon","seaguel","sparrow","crow","swallow" };

	//반복자를 사용하라.

	transform(begin(rts), end(rts),
		ostream_iterator<string>(cout, "\n"),
		[](string& rts) {
		/*for (char& d : rts) {
			if (d == 'a' || d == 'i' || d == 'e' || d == 'o' || d == 'u')
				d = '*';
			}*/
		//원본을 수정하지 않는 버젼
		string s{ rts };
		for (auto i = begin(s); i != end(s); ++i)
			if (*i == 'a'|| *i == 'e'|| *i == 'i'|| *i == 'o'|| *i == 'u')
				*i = '*';
		return s;
		});

	save("소스.cpp");
}

=========================
Tue Mar 26 17:56:19 2019
=========================

//------------------------------------------------------------
//2019.STL 3.19 화9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// 과제 - 책 1장을 읽어보기
// class String을 #include "String.h"로 분리해보자
//------------------------------------------------------------
#include "save.h"
#include "String.h"
#include <memory>
#include <list>
#include <iterator>
using namespace std;

//STL은 속도를 우선한다
int main()
{
	list<string> rts{ "pigeon","seaguel","sparrow","crow","swallow" };

	//반복자를 사용하라.

	transform(begin(rts), end(rts),
		ostream_iterator<string>(cout, "\n"),
		[](string& str) {
		/*for (char& d : rts) {
			if (d == 'a' || d == 'i' || d == 'e' || d == 'o' || d == 'u')
				d = '*';
			}*/
		//원본을 수정하지 않는 버젼
		string s{ str };
		for (auto i = begin(s); i != end(s); ++i)
			if (*i == 'a'|| *i == 'e'|| *i == 'i'|| *i == 'o'|| *i == 'u')
				*i = '*';
		return s;
		});

	for (string& d : rts)
		cout << d << endl;

	save("소스.cpp");
}

=========================
Tue Mar 26 18:01:41 2019
=========================

//------------------------------------------------------------
//2019.STL 3.19 화9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// 과제 - 책 1장을 읽어보기
// class String을 #include "String.h"로 분리해보자
//------------------------------------------------------------
#include "save.h"
#include "String.h"
#include <memory>
#include <list>
#include <iterator>
using namespace std;

//STL은 속도를 우선한다
int main()
{
	list<string> rts{ "pigeon","seaguel","sparrow","crow","swallow" };

	//반복자를 사용하라.

	transform(begin(rts), end(rts),
		ostream_iterator<string>(cout, "\n"),
		[](string& str) {
		/*for (char& d : rts) {
			if (d == 'a' || d == 'i' || d == 'e' || d == 'o' || d == 'u')
				d = '*';
			}*/
		//원본을 수정하지 않는 버젼
		string s{ str };
		for (int i = 0; i < str.size(); ++i)
			toupper(str[i]);
		return str;
		});

	for (string& d : rts)
		cout << d << endl;

	save("소스.cpp");
}

=========================
Tue Mar 26 18:02:46 2019
=========================

//------------------------------------------------------------
//2019.STL 3.19 화9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// 과제 - 책 1장을 읽어보기
// class String을 #include "String.h"로 분리해보자
//------------------------------------------------------------
#include "save.h"
#include "String.h"
#include <memory>
#include <list>
#include <iterator>
using namespace std;

//STL은 속도를 우선한다
int main()
{
	list<string> rts{ "pigeon","seaguel","sparrow","crow","swallow" };

	//반복자를 사용하라.

	transform(begin(rts), end(rts),
		ostream_iterator<string>(cout, "\n"),
		[](string& str) {
		/*for (char& d : rts) {
			if (d == 'a' || d == 'i' || d == 'e' || d == 'o' || d == 'u')
				d = '*';
			}*/
		//원본을 수정하지 않는 버젼
		string s{ str };
		for (int i = 0; i < str.size(); ++i)
			str[i] = toupper(str[i]);
		return str;
		});

	for (string& d : rts)
		cout << d << endl;

	save("소스.cpp");
}

=========================
Tue Mar 26 18:05:22 2019
=========================

//------------------------------------------------------------
//2019.STL 3.19 화9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// 과제 - 책 1장을 읽어보기
// class String을 #include "String.h"로 분리해보자
//------------------------------------------------------------
#include "save.h"
#include "String.h"
#include <memory>
#include <list>
#include <iterator>
using namespace std;

//STL은 속도를 우선한다
int main()
{
	list<string> rts{ "pigeon","seaguel","sparrow","crow","swallow" };

	//반복자를 사용하라.

	transform(begin(rts), end(rts),
		ostream_iterator<string>(cout, "\n"),
		[](string& str) {
		transform(begin(str), end(str), begin(str), [](char& c) {
			c = toupper(c);
			return c;
		});
		return str;
		});

	for (string& d : rts)
		cout << d << endl;

	save("소스.cpp");
}

=========================
Tue Mar 26 18:27:05 2019
=========================

//------------------------------------------------------------
//2019.STL 3.19 화9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
// - array
// - vector
// - deque
// - list
// - forward_list
// 동일한 타입만 담는다.
// 순차의 의미는 데이터를 아무 위치에다 프로그래머 임의로 저장할 수 있다는 것.
//------------------------------------------------------------
#include "save.h"
#include "String.h"
#include <array>
using namespace std;

int main()
{
	array<int, 10>a;

	cout << sizeof(a);

	save("소스.cpp");
}

=========================
Tue Mar 26 18:30:11 2019
=========================

//------------------------------------------------------------
//2019.STL 3.19 화9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
// - array
// - vector
// - deque
// - list
// - forward_list
// 동일한 타입만 담는다.
// 순차의 의미는 데이터를 아무 위치에다 프로그래머 임의로 저장할 수 있다는 것.
//------------------------------------------------------------
#include "save.h"
#include "String.h"
#include <array>
using namespace std;

int main()
{
	array<int, 5>a{ 1,2,3,4,5 };

	for (int i = 0; i < a.size(); ++i)
		cout << a[i] << endl;

	save("소스.cpp");
}

=========================
Tue Mar 26 18:31:52 2019
=========================

//------------------------------------------------------------
//2019.STL 3.19 화9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
// - array
// - vector
// - deque
// - list
// - forward_list
// 동일한 타입만 담는다.
// 순차의 의미는 데이터를 아무 위치에다 프로그래머 임의로 저장할 수 있다는 것.
//------------------------------------------------------------
#include "save.h"
#include "String.h"
#include <array>
using namespace std;

int main()
{
	array<int, 5>a{ 1,2,3,4,5 };

	for (auto i = a.begin(); i != a.end(); ++i)
		cout << *i << endl;

	save("소스.cpp");
}

=========================
Tue Mar 26 18:33:43 2019
=========================

//------------------------------------------------------------
//2019.STL 3.19 화9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
// - array
// - vector
// - deque
// - list
// - forward_list
// 동일한 타입만 담는다.
// 순차의 의미는 데이터를 아무 위치에다 프로그래머 임의로 저장할 수 있다는 것.
//------------------------------------------------------------
#include "save.h"
#include "String.h"
#include <array>
using namespace std;

int main()
{
	array<int, 5>a{ 1,2,3,4,5 };
	auto i = a.begin();
	while (i != a.end())
		cout << *i++ << endl;

	save("소스.cpp");
}

=========================
Tue Mar 26 18:35:38 2019
=========================

//------------------------------------------------------------
//2019.STL 3.19 화9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
// - array
// - vector
// - deque
// - list
// - forward_list
// 동일한 타입만 담는다.
// 순차의 의미는 데이터를 아무 위치에다 프로그래머 임의로 저장할 수 있다는 것.
//------------------------------------------------------------
#include "save.h"
#include "String.h"
#include <array>
#include <list>
using namespace std;

int main()
{
	list<int>a{ 1,2,3,4,5 };



	auto i = a.begin();//자료구조와 알고리즘을 연결해주는 interface
	while (i != a.end())
		cout << *i++ << endl;

	save("소스.cpp");
}

=========================
Tue Mar 26 18:56:00 2019
=========================

//------------------------------------------------------------
//2019.STL 3.19 화9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
// - array
// - vector
// - deque
// - list
// - forward_list
// 동일한 타입만 담는다.
// 순차의 의미는 데이터를 아무 위치에다 프로그래머 임의로 저장할 수 있다는 것.
//------------------------------------------------------------
#include "save.h"
#include "String.h"
#include <array>
using namespace std;

int main()
{
	array<String,5>a{ 13,22,3,54,20 };//<>안에 들어오는 것은 자료형,array의 경우 숫자도 자료형처럼 들어간다.

	for (int i = 0; i < a.size(); ++i)
		cout << a[i] << endl;
	
	save("소스.cpp");
}

=========================
Thu Mar 28 18:01:29 2019
=========================

//------------------------------------------------------------
//2019.STL 3.19 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
// - array
// - vector
// - deque
// - list
// - forward_list
// 동일한 타입만 담는다.
// 순차의 의미는 데이터를 아무 위치에다 프로그래머 임의로 저장할 수 있다는 것.
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <array>
using namespace std;

int main()
{
	
	
	save("소스.cpp");
	save("String.h");
	save("String.cpp");
}

=========================
Thu Mar 28 18:01:29 2019
=========================

// String.h - 소문자를 random하게 HEAP에 저장하고 있다.
#pragma once
#include <iostream>

class String {
	int num{ 0 };
	char *p{ nullptr };
public:
	String() = default;

	String(int n);

	~String();

	String(const String& other);

	String& operator=(const String& other);

	void reset(int n);

	int getNum() const;

	char* getData() const;

	friend std::ostream& operator<<(std::ostream&, const String&);
};


=========================
Thu Mar 28 18:01:29 2019
=========================

#include "String.h"
#include <random>

std::uniform_int_distribution<> uid('a', 'z');
std::default_random_engine dre;

String::String(int n) :num{ n } {
	p = new char[num];
	for (int i = 0; i < num; ++i)
		p[i] = uid(dre);
}

String::~String() {
	//cout << "소멸" << endl;
	delete[] p;
}

String::String(const String& other) :num{ other.num } {
	p = new char[num];
	memcpy(p, other.p, num);
}

String& String::operator=(const String& other) {
	if (this == &other)
		return *this;
	delete[] p;
	num = other.num;
	p = new char[num];
	memcpy(p, other.p, num);
	return *this;
}

void String::reset(int n) {
	num = n;
	if (p == nullptr)
		delete[] p;

	p = new char[num];
	for (int i = 0; i < num; ++i)
		p[i] = uid(dre);
}

int String::getNum() const {
	return num;
}

char* String::getData() const { return p; }



std::ostream& operator<<(std::ostream& os, const String& str)
{
	for (int i = 0; i < str.num; ++i)
		os << str.p[i];
	return os;
}


=========================
Thu Mar 28 18:06:58 2019
=========================

//------------------------------------------------------------
//2019.STL 3.19 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
//   array
// - vector
//   deque
//   list
//   forward_list
// 동일한 타입만 담는다.
// 순차의 의미는 데이터를 아무 위치에다 프로그래머 임의로 저장할 수 있다는 것.
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <vector>
using namespace std;

int main()
{
	vector<String> v;
	cout << sizeof(v) << endl;
	save("소스.cpp");
}

=========================
Thu Mar 28 18:07:08 2019
=========================

//------------------------------------------------------------
//2019.STL 3.19 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
//   array
// - vector
//   deque
//   list
//   forward_list
// 동일한 타입만 담는다.
// 순차의 의미는 데이터를 아무 위치에다 프로그래머 임의로 저장할 수 있다는 것.
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <vector>
using namespace std;

int main()
{
	vector<int> v;
	cout << sizeof(v) << endl;
	save("소스.cpp");
}

=========================
Thu Mar 28 18:12:37 2019
=========================

//------------------------------------------------------------
//2019.STL 3.19 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
//   array
// - vector
//   deque
//   list
//   forward_list
// 동일한 타입만 담는다.
// 순차의 의미는 데이터를 아무 위치에다 프로그래머 임의로 저장할 수 있다는 것.
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <vector>
using namespace std;

int main()
{
	vector<String> v;
	v.push_back(String(10));
	cout << v.size() << endl;
	save("소스.cpp");
}

=========================
Thu Mar 28 18:12:52 2019
=========================

//------------------------------------------------------------
//2019.STL 3.19 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
//   array
// - vector
//   deque
//   list
//   forward_list
// 동일한 타입만 담는다.
// 순차의 의미는 데이터를 아무 위치에다 프로그래머 임의로 저장할 수 있다는 것.
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <vector>
using namespace std;

int main()
{
	vector<String> v(5);
	v.push_back(String(10));
	cout << v.size() << endl;
	save("소스.cpp");
}

=========================
Thu Mar 28 18:23:05 2019
=========================

//------------------------------------------------------------
//2019.STL 3.19 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
//   array
// - vector
//   deque
//   list
//   forward_list
// 동일한 타입만 담는다.
// 순차의 의미는 데이터를 아무 위치에다 프로그래머 임의로 저장할 수 있다는 것.
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <vector>
using namespace std;

int main()
{
	vector<String> v { 1, 3, 5, 7, 9 };
	for (int i = 0; i < v.size(); ++i)
		cout << v[i] << endl;
	save("소스.cpp");
}

=========================
Thu Mar 28 18:28:49 2019
=========================

//------------------------------------------------------------
//2019.STL 3.19 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
//   array
// - vector
//   deque
//   list
//   forward_list
// 동일한 타입만 담는다.
// 순차의 의미는 데이터를 아무 위치에다 프로그래머 임의로 저장할 수 있다는 것.
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <vector>
using namespace std;

int main()
{
	vector<String> v{ 1,3,5,7,9 };
	for (auto i = v.begin(); i != v.end(); i++)
		cout << *i << endl;
	save("소스.cpp");
}

=========================
Thu Mar 28 18:31:12 2019
=========================

//------------------------------------------------------------
//2019.STL 3.19 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
//   array
// - vector
//   deque
//   list
//   forward_list
// 동일한 타입만 담는다.
// 순차의 의미는 데이터를 아무 위치에다 프로그래머 임의로 저장할 수 있다는 것.
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <vector>
using namespace std;

int main()
{
	vector<String> v{ 1,3,5,7,9 };
	for (auto i = v.begin(); i != v.end(); ++i)
		cout << *i << endl;
	cout << "Size : " << v.size() << endl;
	cout << "Capacity : " << v.capacity() << endl;
	save("소스.cpp");
}

=========================
Thu Mar 28 18:34:03 2019
=========================

//------------------------------------------------------------
//2019.STL 3.19 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
//   array
// - vector
//   deque
//   list
//   forward_list
// 동일한 타입만 담는다.
// 순차의 의미는 데이터를 아무 위치에다 프로그래머 임의로 저장할 수 있다는 것.
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <vector>
using namespace std;

int main()
{
	vector<String> v{ 1,3,5,7,9 };
	for (auto i = v.begin(); i != v.end(); ++i)
		cout << *i << endl;
	cout << "Size : " << v.size() << endl;
	cout << "Capacity : " << v.capacity() << endl;

	//원소 한 개 더 추가
	v.push_back(10);

	cout << "Size : " << v.size() << endl;
	cout << "Capacity : " << v.capacity() << endl;

	save("소스.cpp");
}

=========================
Thu Mar 28 18:53:17 2019
=========================

//------------------------------------------------------------
//2019.STL 3.19 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
//   array
// - vector
//   deque
//   list
//   forward_list
// 동일한 타입만 담는다.
// 순차의 의미는 데이터를 아무 위치에다 프로그래머 임의로 저장할 수 있다는 것.
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <vector>
using namespace std;


int main()
{
	std::uniform_int_distribution<> uid(10, 70);
	std::default_random_engine dre;
	// v에 길이가 uid(10,70)인 String 20개를 추가하라
	vector<String> v(20);
	for (auto i = v.begin(); i != v.end(); ++i) {
		*i=String(uid(dre));
	}

	// v의 String을 길이 오름차순으로 정렬하라
	sort(v.begin(), v.end(), [](const String& a, const String& b) {
		return a.getNum() > b.getNum();
	});
	// v의 모든 String을 출력하라
	for (const String& str : v)	//복사 방지 원본 훼손 방지
		cout << str << endl;
	save("소스.cpp");
}

=========================
Thu Mar 28 18:53:27 2019
=========================

//------------------------------------------------------------
//2019.STL 3.19 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
//   array
// - vector
//   deque
//   list
//   forward_list
// 동일한 타입만 담는다.
// 순차의 의미는 데이터를 아무 위치에다 프로그래머 임의로 저장할 수 있다는 것.
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <vector>
using namespace std;


int main()
{
	std::uniform_int_distribution<> uid(10, 70);
	std::default_random_engine dre;
	// v에 길이가 uid(10,70)인 String 20개를 추가하라
	vector<String> v(20);
	for (auto i = v.begin(); i != v.end(); ++i) {
		*i=String(uid(dre));
	}

	// v의 String을 길이 오름차순으로 정렬하라
	sort(v.begin(), v.end(), [](const String& a, const String& b) {
		return a.getNum() < b.getNum();
	});
	// v의 모든 String을 출력하라
	for (const String& str : v)	//복사 방지 원본 훼손 방지
		cout << str << endl;
	save("소스.cpp");
}

=========================
Thu Mar 28 18:53:50 2019
=========================

//------------------------------------------------------------
//2019.STL 3.19 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
//   array
// - vector
//   deque
//   list
//   forward_list
// 동일한 타입만 담는다.
// 순차의 의미는 데이터를 아무 위치에다 프로그래머 임의로 저장할 수 있다는 것.
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <vector>
using namespace std;


int main()
{
	std::uniform_int_distribution<> uid(10, 70);
	std::default_random_engine dre;
	// v에 길이가 uid(10,70)인 String 20개를 추가하라
	vector<String> v(20);
	for (auto i = v.begin(); i != v.end(); ++i) {
		*i=String(uid(dre));
	}

	// v의 String을 길이 오름차순으로 정렬하라
	sort(v.begin(), v.end(), [](const String& a, const String& b) {
		return a.getNum() < b.getNum();
	});
	// v의 모든 String을 출력하라
	for (const String& str : v)	//복사 방지 원본 훼손 방지
		cout << str << endl;
	save("소스.cpp");
}

=========================
Thu Mar 28 18:59:42 2019
=========================

//------------------------------------------------------------
//2019.STL 3.19 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
//   array
// - vector
//   deque
//   list
//   forward_list
// 동일한 타입만 담는다.
// 순차의 의미는 데이터를 아무 위치에다 프로그래머 임의로 저장할 수 있다는 것.
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <vector>
using namespace std;


int main()
{
	std::uniform_int_distribution<> uid(10, 70);
	std::default_random_engine dre;
	vector<String> v;
	v.reserve(20);
	// v에 길이가 uid(10,70)인 String 20개를 추가하라
	for (int i = 0; i <20; ++i) {
		v.emplace_back(uid(dre));
	}
	// v의 String을 길이 오름차순으로 정렬하라
	sort(v.begin(), v.end(), [](const String& a, const String& b) {
		return a.getNum() < b.getNum();
	});
	// v의 모든 String을 출력하라
	for (const String& str : v) {	//복사 방지 원본 훼손 방지
		cout << str << endl;
		cout << "Size : " << v.size() << endl;
		cout << "Capacity : " << v.capacity() << endl;
	}
	save("소스.cpp");
}

=========================
Thu Mar 28 19:00:08 2019
=========================

//------------------------------------------------------------
//2019.STL 3.19 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
//   array
// - vector
//   deque
//   list
//   forward_list
// 동일한 타입만 담는다.
// 순차의 의미는 데이터를 아무 위치에다 프로그래머 임의로 저장할 수 있다는 것.
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <vector>
using namespace std;


int main()
{
	std::uniform_int_distribution<> uid(10, 70);
	std::default_random_engine dre;
	vector<String> v;
	v.reserve(20);
	// v에 길이가 uid(10,70)인 String 20개를 추가하라
	for (int i = 0; i <20; ++i) {
		v.emplace_back(uid(dre));
	}
	// v의 String을 길이 오름차순으로 정렬하라
	sort(v.begin(), v.end(), [](const String& a, const String& b) {
		return a.getNum() < b.getNum();
	});
	// v의 모든 String을 출력하라
	for (const String& str : v) {	//복사 방지 원본 훼손 방지
		cout << str << endl;
	}
	cout << "Size : " << v.size() << endl;
	cout << "Capacity : " << v.capacity() << endl;
	save("소스.cpp");
}

=========================
Tue Apr  2 18:56:00 2019
=========================

//------------------------------------------------------------
//2019.STL 4.2 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
//   array	[]대신 사용
// - vector	dynamic array
//   deque
//   list
//   forward_list
// 동일한 타입만 담는다.
// 순차의 의미는 데이터를 아무 위치에다 프로그래머 임의로 저장할 수 있다는 것.
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <vector>
#include <string>
#include <iterator>
#include <algorithm>
using namespace std;

//키보드에서 단어를 읽어 정렬 후 화면 출력하라.

//입력자료구조 - 키보드
//출력자료구조 - 화면

int main()
{
	vector<string> v{ istream_iterator<string>(cin), istream_iterator<string>() };
	sort(v.begin(), v.end());
	copy(v.begin(), v.end(), ostream_iterator<string>(cout, "\t"));
	save("소스.cpp");
}

=========================
Tue Apr  2 18:57:12 2019
=========================

//------------------------------------------------------------
//2019.STL 4.2 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
//   array	[]대신 사용
// - vector	dynamic array
//   deque
//   list
//   forward_list
// 동일한 타입만 담는다.
// 순차의 의미는 데이터를 아무 위치에다 프로그래머 임의로 저장할 수 있다는 것.
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <vector>
#include <string>
#include <iterator>
#include <algorithm>
using namespace std;

//키보드에서 단어를 읽어 정렬 후 화면 출력하라.

//입력자료구조 - 키보드
//출력자료구조 - 화면

int main()
{
	vector<string> v{ istream_iterator<string>(cin), istream_iterator<string>() };
	sort(v.begin(), v.end());
	copy(v.begin(), v.end(), ostream_iterator<string>(cout, "\t"));
	save("소스.cpp");
}

=========================
Tue Apr  2 18:58:48 2019
=========================

//------------------------------------------------------------
//2019.STL 4.2 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
//   array	[]대신 사용
// - vector	dynamic array
//   deque
//   list
//   forward_list
// 동일한 타입만 담는다.
// 순차의 의미는 데이터를 아무 위치에다 프로그래머 임의로 저장할 수 있다는 것.
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <vector>
#include <string>
#include <iterator>
#include <algorithm>
using namespace std;

//키보드에서 단어를 읽어 정렬 후 화면 출력하라.

//입력자료구조 - 키보드
//출력자료구조 - 화면

int main()
{
	vector<string> v{ istream_iterator<string>(cin), istream_iterator<string>( ) };
	sort(v.begin(), v.end());
	copy(v.begin(), v.end(), ostream_iterator<string>(cout, "\t"));
	save("소스.cpp");
}

=========================
Tue Apr  2 18:59:24 2019
=========================

//------------------------------------------------------------
//2019.STL 4.2 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
//   array	[]대신 사용
// - vector	dynamic array
//   deque
//   list
//   forward_list
// 동일한 타입만 담는다.
// 순차의 의미는 데이터를 아무 위치에다 프로그래머 임의로 저장할 수 있다는 것.
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <vector>
#include <string>
#include <iterator>
#include <algorithm>
using namespace std;

//키보드에서 단어를 읽어 정렬 후 화면 출력하라.

//입력자료구조 - 키보드
//출력자료구조 - 화면

int main()
{
	vector<string> v{ istream_iterator<string>(cin), istream_iterator<string>( ) };
	sort(v.begin(), v.end());
	copy(v.begin(), v.end(), ostream_iterator<string>(cout, "\t"));
	save("소스.cpp");
}

=========================
Thu Apr  4 17:33:13 2019
=========================

//------------------------------------------------------------
//2019.STL 4.2 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
//   array	[]대신 사용
// - vector	dynamic array
//   deque
//   list
//   forward_list
// 동일한 타입만 담는다.
// 순차의 의미는 데이터를 아무 위치에다 프로그래머 임의로 저장할 수 있다는 것.
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <vector>
#include <string>
#include <iterator>
#include <algorithm>
using namespace std;

//키보드에서 단어를 읽어 정렬 후 화면 출력하라.

//입력자료구조 - 키보드
//출력자료구조 - 화면

int main()
{
	vector<String> v;
	v.reserve(10);

	v.emplace_back(10);
	v.emplace_back(20);
	save("소스.cpp");
}

=========================
Thu Apr  4 17:36:54 2019
=========================

//------------------------------------------------------------
//2019.STL 4.2 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
//   array	[]대신 사용
// - vector	dynamic array
//   deque
//   list
//   forward_list
// 동일한 타입만 담는다.
// 순차의 의미는 데이터를 아무 위치에다 프로그래머 임의로 저장할 수 있다는 것.
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <vector>
#include <string>
#include <iterator>
#include <algorithm>
using namespace std;

//키보드에서 단어를 읽어 정렬 후 화면 출력하라.

//입력자료구조 - 키보드
//출력자료구조 - 화면

int main()
{
	vector<String> v;
	v.reserve(10);

	v.emplace_back(10);
	v.emplace_back(20);


	//여기에서 10과 20사이에 15를 삽입하라
	v.emplace(v.begin() + 1, 15);

	save("소스.cpp");
}

=========================
Thu Apr  4 17:37:43 2019
=========================

//------------------------------------------------------------
//2019.STL 4.2 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
//   array	[]대신 사용
// - vector	dynamic array
//   deque
//   list
//   forward_list
// 동일한 타입만 담는다.
// 순차의 의미는 데이터를 아무 위치에다 프로그래머 임의로 저장할 수 있다는 것.
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <vector>
#include <string>
#include <iterator>
#include <algorithm>
using namespace std;

//키보드에서 단어를 읽어 정렬 후 화면 출력하라.

//입력자료구조 - 키보드
//출력자료구조 - 화면

int main()
{
	vector<String> v;
	v.reserve(10);

	v.emplace_back(10);
	v.emplace_back(20);


	//여기에서 10과 20사이에 15를 삽입하라
	v.emplace(v.begin() + 1, 15);

	save("소스.cpp");

	cout << "------------------" << endl;
	for (int i = 0; i < v.size(); ++i)
	{
		cout << v[i] << endl;
	}
}

=========================
Thu Apr  4 17:53:04 2019
=========================

//------------------------------------------------------------
//2019.STL 4.4 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
//   array	[]대신 사용
// - vector	dynamic array
//   deque
//   list
//   forward_list
// 동일한 타입만 담는다.
// 순차의 의미는 데이터를 아무 위치에다 프로그래머 임의로 저장할 수 있다는 것.
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <vector>
#include <string>
#include <iterator>
#include <algorithm>
using namespace std;

int main()
{
	vector<String> v;
	v.reserve(10);

	v.emplace_back(10);
	v.emplace_back(20);
	v.emplace_back(30);

	//벡터의 2번째 원소를 삭제하시오.
	remove(v.begin(),v.end(),String(20));

	save("소스.cpp");

	cout << "------------------" << endl;
	for (int i = 0; i < v.size(); ++i)
	{
		cout << v[i] << endl;
	}
}

=========================
Thu Apr  4 17:54:46 2019
=========================

//------------------------------------------------------------
//2019.STL 4.4 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
//   array	[]대신 사용
// - vector	dynamic array
//   deque
//   list
//   forward_list
// 동일한 타입만 담는다.
// 순차의 의미는 데이터를 아무 위치에다 프로그래머 임의로 저장할 수 있다는 것.
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <vector>
#include <string>
#include <iterator>
#include <algorithm>
using namespace std;

int main()
{
	vector<String> v;
	v.reserve(10);

	v.emplace_back(10);
	v.emplace_back(20);
	v.emplace_back(30);

	//벡터의 2번째 원소를 삭제하시오.
	remove(v.begin(),v.end(),String(20));

	save("소스.cpp");

	cout << "------------------" << endl;
	for (int i = 0; i < v.size(); ++i)
	{
		cout << v[i] << endl;
	}
}

=========================
Thu Apr  4 17:56:54 2019
=========================

//------------------------------------------------------------
//2019.STL 4.4 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
//   array	[]대신 사용
// - vector	dynamic array
//   deque
//   list
//   forward_list
// 동일한 타입만 담는다.
// 순차의 의미는 데이터를 아무 위치에다 프로그래머 임의로 저장할 수 있다는 것.
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <vector>
#include <string>
#include <iterator>
#include <algorithm>
using namespace std;

int main()
{
	vector<String> v;
	v.reserve(10);

	v.emplace_back(10);
	v.emplace_back(20);
	v.emplace_back(30);
	v.emplace_back(40);
	v.emplace_back(50);

	//벡터의 2번째 원소를 삭제하시오.
	String a{ 20 };
	remove(v.begin(),v.end(),a);

	save("소스.cpp");

	cout << "------------------" << endl;
	for (int i = 0; i < v.size(); ++i)
	{
		cout << v[i] << endl;
	}
}

=========================
Thu Apr  4 18:04:54 2019
=========================

//------------------------------------------------------------
//2019.STL 4.4 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
//   array	[]대신 사용
// - vector	dynamic array
//   deque
//   list
//   forward_list
// 동일한 타입만 담는다.
// 순차의 의미는 데이터를 아무 위치에다 프로그래머 임의로 저장할 수 있다는 것.
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <vector>
#include <string>
#include <iterator>
#include <algorithm>
using namespace std;

int main()
{
	vector<String> v;
	v.reserve(10);

	v.emplace_back(10);
	v.emplace_back(20);
	v.emplace_back(30);
	v.emplace_back(40);
	v.emplace_back(50);

	//벡터의 2번째 원소를 삭제하시오.
	String a{ 20 };
	auto newEnd = remove(v.begin(),v.end(),a);
	v.erase(newEnd, v.end());


	save("소스.cpp");

	cout << "------------------" << endl;
	for (int i = 0; i < v.size(); ++i)
	{
		cout << v[i] << endl;
	}
}

=========================
Thu Apr  4 18:05:19 2019
=========================

//------------------------------------------------------------
//2019.STL 4.4 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
//   array	[]대신 사용
// - vector	dynamic array
//   deque
//   list
//   forward_list
// 동일한 타입만 담는다.
// 순차의 의미는 데이터를 아무 위치에다 프로그래머 임의로 저장할 수 있다는 것.
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <vector>
#include <string>
#include <iterator>
#include <algorithm>
using namespace std;

int main()
{
	vector<String> v;
	v.reserve(10);

	v.emplace_back(10);
	v.emplace_back(20);
	v.emplace_back(30);

	//벡터의 2번째 원소를 삭제하시오.
	String a{ 20 };
	auto newEnd = remove(v.begin(),v.end(),a);
	v.erase(newEnd, v.end());


	save("소스.cpp");

	cout << "------------------" << endl;
	for (int i = 0; i < v.size(); ++i)
	{
		cout << v[i] << endl;
	}
}

=========================
Thu Apr  4 18:06:40 2019
=========================

//------------------------------------------------------------
//2019.STL 4.4 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
//   array	[]대신 사용
// - vector	dynamic array
//   deque
//   list
//   forward_list
// 동일한 타입만 담는다.
// 순차의 의미는 데이터를 아무 위치에다 프로그래머 임의로 저장할 수 있다는 것.
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <vector>
#include <string>
#include <iterator>
#include <algorithm>
using namespace std;

int main()
{
	vector<String> v;
	v.reserve(10);

	v.emplace_back(10);
	v.emplace_back(20);
	v.emplace_back(30);

	//벡터의 2번째 원소를 삭제하시오.
	String a{ 20 };
	//erase-remove idiom을 사용하여 삭제하여하 함.
	v.erase(remove(v.begin(), v.end(), a), v.end());


	save("소스.cpp");

	cout << "------------------" << endl;
	for (int i = 0; i < v.size(); ++i)
	{
		cout << v[i] << endl;
	}
}

=========================
Thu Apr  4 18:36:53 2019
=========================

//------------------------------------------------------------
//2019.STL 4.4 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
//   array	[]대신 사용
// - vector	dynamic array
//   deque	double-ended queue
//   list
//   forward_list
// 동일한 타입만 담는다.
// 순차의 의미는 데이터를 아무 위치에다 프로그래머 임의로 저장할 수 있다는 것.
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <deque>
using namespace std;

// "덱"에 String 객체를 1,2,3,4,5를 추가해 보세요.
// 화면에 "덱"의 원소를 출력해 보세요.
int main()
{
	deque<String> d{ 1,2,3,4,5 };
	for (int i = 0; i < d.size(); ++i)
	{
		cout << d[i] << endl;
	}
	save("소스.cpp");
}

=========================
Thu Apr  4 18:45:43 2019
=========================

//------------------------------------------------------------
//2019.STL 4.4 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
//   array	[]대신 사용
// - vector	dynamic array
//   deque	double-ended queue
//   list
//   forward_list
// 동일한 타입만 담는다.
// 순차의 의미는 데이터를 아무 위치에다 프로그래머 임의로 저장할 수 있다는 것.
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <deque>
using namespace std;

// "덱"에 String 객체를 1,2,3,4,5를 추가해 보세요.
// 화면에 "덱"의 원소를 출력해 보세요.
int main()
{
	deque<String> d;
	d.emplace(d.end(), 1);
	d.emplace(d.end(), 2);
	d.emplace(d.end(), 3);
	d.emplace(d.end(), 4);
	d.emplace(d.end(), 5);

	save("소스.cpp");
}

=========================
Thu Apr  4 18:46:08 2019
=========================

//------------------------------------------------------------
//2019.STL 4.4 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
//   array	[]대신 사용
// - vector	dynamic array
//   deque	double-ended queue
//   list
//   forward_list
// 동일한 타입만 담는다.
// 순차의 의미는 데이터를 아무 위치에다 프로그래머 임의로 저장할 수 있다는 것.
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <deque>
using namespace std;

// "덱"에 String 객체를 1,2,3,4,5를 추가해 보세요.
// 화면에 "덱"의 원소를 출력해 보세요.
int main()
{
	vector<String> d;
	d.emplace(d.end(), 1);
	d.emplace(d.end(), 2);
	d.emplace(d.end(), 3);
	d.emplace(d.end(), 4);
	d.emplace(d.end(), 5);

	save("소스.cpp");
}

=========================
Thu Apr  4 18:46:21 2019
=========================

//------------------------------------------------------------
//2019.STL 4.4 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
//   array	[]대신 사용
// - vector	dynamic array
//   deque	double-ended queue
//   list
//   forward_list
// 동일한 타입만 담는다.
// 순차의 의미는 데이터를 아무 위치에다 프로그래머 임의로 저장할 수 있다는 것.
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <deque>
using namespace std;

// "덱"에 String 객체를 1,2,3,4,5를 추가해 보세요.
// 화면에 "덱"의 원소를 출력해 보세요.
int main()
{
	deque<String> d;
	d.emplace(d.end(), 1);
	d.emplace(d.end(), 2);
	d.emplace(d.end(), 3);
	d.emplace(d.end(), 4);
	d.emplace(d.end(), 5);

	save("소스.cpp");
}

=========================
Thu Apr  4 18:47:33 2019
=========================

//------------------------------------------------------------
//2019.STL 4.4 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
//   array	[]대신 사용
// - vector	dynamic array
//   deque	double-ended queue
//   list
//   forward_list
// 동일한 타입만 담는다.
// 순차의 의미는 데이터를 아무 위치에다 프로그래머 임의로 저장할 수 있다는 것.
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <deque>
using namespace std;

// "덱"에 String 객체를 1,2,3,4,5를 추가해 보세요.
// 화면에 "덱"의 원소를 출력해 보세요.
int main()
{
	deque<String> d;
	d.emplace(d.end(), 1);
	d.emplace(d.end(), 2);
	d.emplace(d.end(), 3);
	d.emplace(d.end(), 4);
	d.emplace(d.end(), 5);

	for (int i = 0; i < d.size(); ++i)
		cout << d[i] << endl;

	save("소스.cpp");
}

=========================
Thu Apr  4 18:47:54 2019
=========================

//------------------------------------------------------------
//2019.STL 4.4 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
//   array	[]대신 사용
// - vector	dynamic array
//   deque	double-ended queue
//   list
//   forward_list
// 동일한 타입만 담는다.
// 순차의 의미는 데이터를 아무 위치에다 프로그래머 임의로 저장할 수 있다는 것.
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <deque>
using namespace std;

// "덱"에 String 객체를 1,2,3,4,5를 추가해 보세요.
// 화면에 "덱"의 원소를 출력해 보세요.
int main()
{
	deque<String> d;
	d.emplace(d.begin(), 1);
	d.emplace(d.begin(), 2);
	d.emplace(d.begin(), 3);
	d.emplace(d.begin(), 4);
	d.emplace(d.begin(), 5);

	for (int i = 0; i < d.size(); ++i)
		cout << d[i] << endl;

	save("소스.cpp");
}

=========================
Thu Apr  4 18:50:01 2019
=========================

//------------------------------------------------------------
//2019.STL 4.4 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
//   array	[]대신 사용
// - vector	dynamic array
//   deque	double-ended queue
//   list
//   forward_list
// 동일한 타입만 담는다.
// 순차의 의미는 데이터를 아무 위치에다 프로그래머 임의로 저장할 수 있다는 것.
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <deque>
using namespace std;

// "덱"에 String 객체를 1,2,3,4,5를 추가해 보세요.
// 화면에 "덱"의 원소를 출력해 보세요.
int main()
{
	deque<String> d;
	
	d.emplace(d.begin(), 1);
	d.emplace(d.begin(), 2);
	d.emplace(d.begin(), 3);
	d.emplace(d.begin(), 4);
	d.emplace(d.begin(), 5);

	for (int i = 0; i < d.size(); ++i)
		cout << d[i] << endl;

	save("소스.cpp");
}

=========================
Tue Apr  9 17:29:20 2019
=========================

//------------------------------------------------------------
//2019.STL 4.9 화9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
//   array	[]대신 사용
// - vector	dynamic array
//   deque	double-ended queue
//   list
//   forward_list
// 동일한 타입만 담는다.
// 순차의 의미는 데이터를 아무 위치에다 프로그래머 임의로 저장할 수 있다는 것.
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <deque>
using namespace std;

// "덱"에 String 객체를 1,2,3,4,5를 추가해 보세요.
// 화면에 "덱"의 원소를 출력해 보세요.
// "덱"은 한번에 큰 메모리 블록을 할당해서 사용한다.
// 상황에 따라 다른 자료구조들을 활용할 수 있어야 한다.

// 키보드에서 숫자를 입력받아
// deque의 back위치에 삽입해본다.
// 시간없어 실패
//
// 반복자 어댑터 - 자료구조와 알고리즘이 분리되어 있기 때문에
// 알고리즘에서 직접 자료구조의 원소를 삽입조작할 수 없다

int main()
{
	deque<String> d;
	save("소스.cpp");
}

=========================
Tue Apr  9 17:30:13 2019
=========================

//------------------------------------------------------------
//2019.STL 4.9 화9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
//   array	[]대신 사용
// - vector	dynamic array
//   deque	double-ended queue
//   list
//   forward_list
// 동일한 타입만 담는다.
// 순차의 의미는 데이터를 아무 위치에다 프로그래머 임의로 저장할 수 있다는 것.
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <deque>
using namespace std;

// "덱"에 String 객체를 1,2,3,4,5를 추가해 보세요.
// 화면에 "덱"의 원소를 출력해 보세요.
// "덱"은 한번에 큰 메모리 블록을 할당해서 사용한다.
// 상황에 따라 다른 자료구조들을 활용할 수 있어야 한다.

// 키보드에서 숫자를 입력받아
// deque의 back위치에 삽입해본다.
// 시간없어 실패
//
// 반복자 어댑터 - 자료구조와 알고리즘이 분리되어 있기 때문에
// 알고리즘에서 직접 자료구조의 원소를 삽입조작할 수 없다

int main()
{
	deque<String> d;
	save("소스.cpp");
}

=========================
Tue Apr  9 17:30:17 2019
=========================

//------------------------------------------------------------
//2019.STL 4.9 화9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
//   array	[]대신 사용
// - vector	dynamic array
//   deque	double-ended queue
//   list
//   forward_list
// 동일한 타입만 담는다.
// 순차의 의미는 데이터를 아무 위치에다 프로그래머 임의로 저장할 수 있다는 것.
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <deque>
using namespace std;

// "덱"에 String 객체를 1,2,3,4,5를 추가해 보세요.
// 화면에 "덱"의 원소를 출력해 보세요.
// "덱"은 한번에 큰 메모리 블록을 할당해서 사용한다.
// 상황에 따라 다른 자료구조들을 활용할 수 있어야 한다.

// 키보드에서 숫자를 입력받아
// deque의 back위치에 삽입해본다.
// 시간없어 실패
//
// 반복자 어댑터 - 자료구조와 알고리즘이 분리되어 있기 때문에
// 알고리즘에서 직접 자료구조의 원소를 삽입조작할 수 없다

int main()
{
	deque<String> d;
	save("소스.cpp");
}

=========================
Tue Apr  9 17:32:07 2019
=========================

//------------------------------------------------------------
//2019.STL 4.9 화9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
//   array	[]대신 사용
// - vector	dynamic array
//   deque	double-ended queue
//   list
//   forward_list
// 동일한 타입만 담는다.
// 순차의 의미는 데이터를 아무 위치에다 프로그래머 임의로 저장할 수 있다는 것.
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <deque>
using namespace std;

// "덱"에 String 객체를 1,2,3,4,5를 추가해 보세요.
// 화면에 "덱"의 원소를 출력해 보세요.
// "덱"은 한번에 큰 메모리 블록을 할당해서 사용한다.
// 상황에 따라 다른 자료구조들을 활용할 수 있어야 한다.

// 키보드에서 숫자를 입력받아
// deque의 back위치에 삽입해본다.
// 시간없어 실패
//
// 반복자 어댑터 - 자료구조와 알고리즘이 분리되어 있기 때문에
// 알고리즘에서 직접 자료구조의 원소를 삽입조작할 수 없다

int main()
{
	deque<String> d;
	d.emplace_back(10);
	d.emplace_back(20);
	d.emplace_back(30);
	save("소스.cpp");
}

=========================
Tue Apr  9 17:32:43 2019
=========================

//------------------------------------------------------------
//2019.STL 4.9 화9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
//   array	[]대신 사용
// - vector	dynamic array
//   deque	double-ended queue
//   list
//   forward_list
// 동일한 타입만 담는다.
// 순차의 의미는 데이터를 아무 위치에다 프로그래머 임의로 저장할 수 있다는 것.
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <deque>
using namespace std;

// "덱"에 String 객체를 1,2,3,4,5를 추가해 보세요.
// 화면에 "덱"의 원소를 출력해 보세요.
// "덱"은 한번에 큰 메모리 블록을 할당해서 사용한다.
// 상황에 따라 다른 자료구조들을 활용할 수 있어야 한다.

// 키보드에서 숫자를 입력받아
// deque의 back위치에 삽입해본다.
// 시간없어 실패
//
// 반복자 어댑터 - 자료구조와 알고리즘이 분리되어 있기 때문에
// 알고리즘에서 직접 자료구조의 원소를 삽입조작할 수 없다

int main()
{
	deque<String> d;
	d.emplace_back(10);
	d.emplace_back(20);
	d.emplace_back(30);

	for (int i = 0; i < d.size(); ++i)
		cout << d[i] << endl;

	save("소스.cpp");
}

=========================
Tue Apr  9 17:33:24 2019
=========================

//------------------------------------------------------------
//2019.STL 4.9 화9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
//   array	[]대신 사용
// - vector	dynamic array
//   deque	double-ended queue
//   list
//   forward_list
// 동일한 타입만 담는다.
// 순차의 의미는 데이터를 아무 위치에다 프로그래머 임의로 저장할 수 있다는 것.
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <deque>
using namespace std;

// "덱"에 String 객체를 1,2,3,4,5를 추가해 보세요.
// 화면에 "덱"의 원소를 출력해 보세요.
// "덱"은 한번에 큰 메모리 블록을 할당해서 사용한다.
// 상황에 따라 다른 자료구조들을 활용할 수 있어야 한다.

// 키보드에서 숫자를 입력받아
// deque의 back위치에 삽입해본다.
// 시간없어 실패
//
// 반복자 어댑터 - 자료구조와 알고리즘이 분리되어 있기 때문에
// 알고리즘에서 직접 자료구조의 원소를 삽입조작할 수 없다

int main()
{
	deque<String> d;
	d.push_back(10);
	d.push_back(20);
	d.push_back(30);

	for (int i = 0; i < d.size(); ++i)
		cout << d[i] << endl;

	save("소스.cpp");
}

=========================
Tue Apr  9 17:40:12 2019
=========================

//------------------------------------------------------------
//2019.STL 4.9 화9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
//   array	[]대신 사용
// - vector	dynamic array
//   deque	double-ended queue
//   list
//   forward_list
// 동일한 타입만 담는다.
// 순차의 의미는 데이터를 아무 위치에다 프로그래머 임의로 저장할 수 있다는 것.
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <deque>
using namespace std;

// "덱"에 String 객체를 1,2,3,4,5를 추가해 보세요.
// 화면에 "덱"의 원소를 출력해 보세요.
// "덱"은 한번에 큰 메모리 블록을 할당해서 사용한다.
// 상황에 따라 다른 자료구조들을 활용할 수 있어야 한다.

// 키보드에서 숫자를 입력받아
// deque의 back위치에 삽입해본다.
// 시간없어 실패
//
// 반복자 어댑터 - 자료구조와 알고리즘이 분리되어 있기 때문에
// 알고리즘에서 직접 자료구조의 원소를 삽입조작할 수 없다

int main()
{
	deque<String> d;
	d.emplace_back(10);
	d.emplace_back(20);
	d.emplace_back(30);
	d.emplace_back(40);
	d.emplace_back(50);


	for (int i = 0; i < d.size(); ++i)
		cout << d[i] << endl;

	save("소스.cpp");
}

=========================
Tue Apr  9 17:41:13 2019
=========================

//------------------------------------------------------------
//2019.STL 4.9 화9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
//   array	[]대신 사용
// - vector	dynamic array
//   deque	double-ended queue
//   list
//   forward_list
// 동일한 타입만 담는다.
// 순차의 의미는 데이터를 아무 위치에다 프로그래머 임의로 저장할 수 있다는 것.
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <vector>
using namespace std;

// "덱"에 String 객체를 1,2,3,4,5를 추가해 보세요.
// 화면에 "덱"의 원소를 출력해 보세요.
// "덱"은 한번에 큰 메모리 블록을 할당해서 사용한다.
// 상황에 따라 다른 자료구조들을 활용할 수 있어야 한다.

// 키보드에서 숫자를 입력받아
// deque의 back위치에 삽입해본다.
// 시간없어 실패
//
// 반복자 어댑터 - 자료구조와 알고리즘이 분리되어 있기 때문에
// 알고리즘에서 직접 자료구조의 원소를 삽입조작할 수 없다

int main()
{
	vector<String> d;
	d.emplace_back(10);
	d.emplace_back(20);
	d.emplace_back(30);
	d.emplace_back(40);
	d.emplace_back(50);


	for (int i = 0; i < d.size(); ++i)
		cout << d[i] << endl;

	save("소스.cpp");
}

=========================
Tue Apr  9 17:43:39 2019
=========================

//------------------------------------------------------------
//2019.STL 4.9 화9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
//   array	[]대신 사용
// - vector	dynamic array
//   deque	double-ended queue
//   list
//   forward_list
// 동일한 타입만 담는다.
// 순차의 의미는 데이터를 아무 위치에다 프로그래머 임의로 저장할 수 있다는 것.
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <vector>
using namespace std;

// "덱"에 String 객체를 1,2,3,4,5를 추가해 보세요.
// 화면에 "덱"의 원소를 출력해 보세요.
// "덱"은 한번에 큰 메모리 블록을 할당해서 사용한다.
// 상황에 따라 다른 자료구조들을 활용할 수 있어야 한다.

// 키보드에서 숫자를 입력받아
// deque의 back위치에 삽입해본다.
// 시간없어 실패
//
// 반복자 어댑터 - 자료구조와 알고리즘이 분리되어 있기 때문에
// 알고리즘에서 직접 자료구조의 원소를 삽입조작할 수 없다

int main()
{
	vector<String> d;
	d.emplace_back(10);
	d.emplace_back(20);
	d.emplace_back(30);
	d.emplace_back(40);
	d.emplace_back(50);


	for (int i = 0; i < d.size(); ++i)
		cout << d[i] << endl;

	save("소스.cpp");
}

=========================
Tue Apr  9 18:14:18 2019
=========================

//------------------------------------------------------------
//2019.STL 4.9 화9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
//   array	[]대신 사용
// - vector	dynamic array
//   deque	double-ended queue
//   list
//   forward_list
// 동일한 타입만 담는다.
// 순차의 의미는 데이터를 아무 위치에다 프로그래머 임의로 저장할 수 있다는 것.
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <deque>
using namespace std;

// "덱"에 String 객체를 1,2,3,4,5를 추가해 보세요.
// 화면에 "덱"의 원소를 출력해 보세요.
// "덱"은 한번에 큰 메모리 블록을 할당해서 사용한다.
// 상황에 따라 다른 자료구조들을 활용할 수 있어야 한다.
// 벡터는 연속되어 있는 자료구조 이지만, 덱은 연속적이지 않다
// 덱은 벡터보다는 크지만 크기를 확정지을 수 없다.
// 덱은 편리함 위주, 벡터는 속도 위주.


// 키보드에서 숫자를 입력받아
// deque의 back위치에 삽입해본다.
// 시간없어 실패
//
// 반복자 어댑터 - 자료구조와 알고리즘이 분리되어 있기 때문에
// 알고리즘에서 직접 자료구조의 원소를 삽입조작할 수 없다

// 소스.cpp를 deque에 저장하자
// 소스.cpp의 내용이 거꾸로 출력되도록 deque에 저장된 내용을 출력하라

int main()
{
	ifstream in("소스.cpp");
	istreambuf_iterator<char> p(in);
	deque<char> d;
	while (p != istreambuf_iterator<char>())
		d.emplace_front(*p++);

	for (char c : d)
		cout << c;

	save("소스.cpp");
}

=========================
Tue Apr  9 18:15:10 2019
=========================

//------------------------------------------------------------
//2019.STL 4.9 화9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
//   array	[]대신 사용
// - vector	dynamic array
//   deque	double-ended queue
//   list
//   forward_list
// 동일한 타입만 담는다.
// 순차의 의미는 데이터를 아무 위치에다 프로그래머 임의로 저장할 수 있다는 것.
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <deque>
using namespace std;

// "덱"에 String 객체를 1,2,3,4,5를 추가해 보세요.
// 화면에 "덱"의 원소를 출력해 보세요.
// "덱"은 한번에 큰 메모리 블록을 할당해서 사용한다.
// 상황에 따라 다른 자료구조들을 활용할 수 있어야 한다.
// 벡터는 연속되어 있는 자료구조 이지만, 덱은 연속적이지 않다
// 덱은 벡터보다는 크지만 크기를 확정지을 수 없다.
// 덱은 편리함 위주, 벡터는 속도 위주.


// 키보드에서 숫자를 입력받아
// deque의 back위치에 삽입해본다.
// 시간없어 실패
//
// 반복자 어댑터 - 자료구조와 알고리즘이 분리되어 있기 때문에
// 알고리즘에서 직접 자료구조의 원소를 삽입조작할 수 없다

// 소스.cpp를 deque에 저장하자
// 소스.cpp의 내용이 거꾸로 출력되도록 deque에 저장된 내용을 출력하라

int main()
{
	ifstream in("소스.cpp");
	istreambuf_iterator<char> p(in);
	deque<char> d;
	while (p != istreambuf_iterator<char>())
		d.emplace_front(*p++);

	for (char c : d)
		cout << c;

	save("소스.cpp");
}

=========================
Tue Apr  9 18:47:00 2019
=========================

//------------------------------------------------------------
//2019.STL 4.9 화9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
//   array	[]대신 사용
//   vector	dynamic array
// - deque	double-ended queue (메모리를 미리 할당해 앞뒤로 사용가능)
//--------------------------------------위는 객체크기만큼 할당,아래는 객체보다 크게 할당
//   list
//   forward_list
// 동일한 타입만 담는다.
// 순차의 의미는 데이터를 아무 위치에다 프로그래머 임의로 저장할 수 있다는 것.
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <list>
using namespace std;

// "덱"은 한번에 큰 메모리 블록을 할당해서 사용한다.
// 상황에 따라 다른 자료구조들을 활용할 수 있어야 한다.
// 벡터는 연속되어 있는 자료구조 이지만, 덱은 연속적이지 않다
// 덱은 벡터보다는 크지만 크기를 확정지을 수 없다.
// 덱은 편리함 위주, 벡터는 속도 위주.


// 키보드에서 숫자를 입력받아
// deque의 back위치에 삽입해본다.
// 시간없어 실패
//
// 반복자 어댑터 - 자료구조와 알고리즘이 분리되어 있기 때문에
// 알고리즘에서 직접 자료구조의 원소를 삽입조작할 수 없다

// list<String>에 {10,20,30}을 초기화 또는 추가해보자
// list의 내용을 화면 출력하라

int main()
{
	list<String> l{ 10,20,30 };
	
	auto i = l.begin();

	while (i != l.end())
	{
		cout << *i << endl;
		*i++;
	}


	save("소스.cpp");
}

=========================
Tue Apr  9 18:54:07 2019
=========================

//------------------------------------------------------------
//2019.STL 4.9 화9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
//   array	[]대신 사용
//   vector	dynamic array
// - deque	double-ended queue (메모리를 미리 할당해 앞뒤로 사용가능)
//--------------------------------------위는 객체크기만큼 할당,아래는 객체보다 크게 할당
//   list
//   forward_list
// 동일한 타입만 담는다.
// 순차의 의미는 데이터를 아무 위치에다 프로그래머 임의로 저장할 수 있다는 것.
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <list>
using namespace std;

// "덱"은 한번에 큰 메모리 블록을 할당해서 사용한다.
// 상황에 따라 다른 자료구조들을 활용할 수 있어야 한다.
// 벡터는 연속되어 있는 자료구조 이지만, 덱은 연속적이지 않다
// 덱은 벡터보다는 크지만 크기를 확정지을 수 없다.
// 덱은 편리함 위주, 벡터는 속도 위주.


// 키보드에서 숫자를 입력받아
// deque의 back위치에 삽입해본다.
// 시간없어 실패
//
// 반복자 어댑터 - 자료구조와 알고리즘이 분리되어 있기 때문에
// 알고리즘에서 직접 자료구조의 원소를 삽입조작할 수 없다

// list<String>에 {10,20,30}을 초기화 또는 추가해보자
// list의 내용을 화면 출력하라

int main()
{
	list<String> l;

	l.emplace(l.begin(), 10);
	l.emplace(l.begin(), 20);
	l.emplace(l.begin(), 30);

	for (auto d : l)
		cout << d << endl;

	save("소스.cpp");
}

=========================
Tue Apr  9 18:54:24 2019
=========================

//------------------------------------------------------------
//2019.STL 4.9 화9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
//   array	[]대신 사용
//   vector	dynamic array
// - deque	double-ended queue (메모리를 미리 할당해 앞뒤로 사용가능)
//--------------------------------------위는 객체크기만큼 할당,아래는 객체보다 크게 할당
//   list
//   forward_list
// 동일한 타입만 담는다.
// 순차의 의미는 데이터를 아무 위치에다 프로그래머 임의로 저장할 수 있다는 것.
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <list>
using namespace std;

// "덱"은 한번에 큰 메모리 블록을 할당해서 사용한다.
// 상황에 따라 다른 자료구조들을 활용할 수 있어야 한다.
// 벡터는 연속되어 있는 자료구조 이지만, 덱은 연속적이지 않다
// 덱은 벡터보다는 크지만 크기를 확정지을 수 없다.
// 덱은 편리함 위주, 벡터는 속도 위주.


// 키보드에서 숫자를 입력받아
// deque의 back위치에 삽입해본다.
// 시간없어 실패
//
// 반복자 어댑터 - 자료구조와 알고리즘이 분리되어 있기 때문에
// 알고리즘에서 직접 자료구조의 원소를 삽입조작할 수 없다

// list<String>에 {10,20,30}을 초기화 또는 추가해보자
// list의 내용을 화면 출력하라

int main()
{
	list<String> l;

	l.emplace(l.begin(), 10);
	l.emplace(l.begin(), 20);
	l.emplace(l.begin(), 30);

	for (auto& d : l)
		cout << d << endl;

	save("소스.cpp");
}

=========================
Tue Apr  9 18:55:07 2019
=========================

//------------------------------------------------------------
//2019.STL 4.9 화9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
//   array	[]대신 사용
//   vector	dynamic array
// - deque	double-ended queue (메모리를 미리 할당해 앞뒤로 사용가능)
//--------------------------------------위는 객체크기만큼 할당,아래는 객체보다 크게 할당
//   list
//   forward_list
// 동일한 타입만 담는다.
// 순차의 의미는 데이터를 아무 위치에다 프로그래머 임의로 저장할 수 있다는 것.
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <list>
using namespace std;

// "덱"은 한번에 큰 메모리 블록을 할당해서 사용한다.
// 상황에 따라 다른 자료구조들을 활용할 수 있어야 한다.
// 벡터는 연속되어 있는 자료구조 이지만, 덱은 연속적이지 않다
// 덱은 벡터보다는 크지만 크기를 확정지을 수 없다.
// 덱은 편리함 위주, 벡터는 속도 위주.


// 키보드에서 숫자를 입력받아
// deque의 back위치에 삽입해본다.
// 시간없어 실패
//
// 반복자 어댑터 - 자료구조와 알고리즘이 분리되어 있기 때문에
// 알고리즘에서 직접 자료구조의 원소를 삽입조작할 수 없다

// list<String>에 {10,20,30}을 초기화 또는 추가해보자
// list의 내용을 화면 출력하라

int main()
{
	list<String> l;

	l.emplace(l.begin(), 10);
	l.emplace(l.begin(), 20);
	l.emplace(l.begin(), 30);

	for (String& d : l)
		cout << d << endl;

	save("소스.cpp");
}

=========================
Thu Apr 11 17:37:52 2019
=========================

//------------------------------------------------------------
//2019.STL 4.11 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
//   array	[]대신 사용
//   vector	dynamic array
//   deque	double-ended queue (메모리를 미리 할당해 앞뒤로 사용가능)
//--------------------------------------위는 객체크기만큼 할당,아래는 객체보다 크게 할당
// - list
//   forward_list
// 반복자 어댑터
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <algorithm>
#include <list>
using namespace std;

// "덱"은 한번에 큰 메모리 블록을 할당해서 사용한다.
// 상황에 따라 다른 자료구조들을 활용할 수 있어야 한다.
// 벡터는 연속되어 있는 자료구조 이지만, 덱은 연속적이지 않다
// 덱은 벡터보다는 크지만 크기를 확정지을 수 없다.
// 덱은 편리함 위주, 벡터는 속도 위주.

// 반복자 어댑터 - 자료구조와 알고리즘이 분리되어 있기 때문에
// 알고리즘에서 직접 자료구조의 원소를 삽입조작할 수 없다

int main()
{
	list<String> l;

	l.emplace(l.begin(), 10);
	l.emplace(l.begin(), 20);
	l.emplace(l.begin(), 30);
	l.emplace(l.begin(), 40);
	l.emplace(l.begin(), 50);
	l.emplace(l.begin(), 60);
	l.emplace(l.begin(), 70);
	l.emplace(l.begin(), 80);
	l.emplace(l.begin(), 90);

	//리스트에서 20의 배수를 제거해주세요. remove_if를 사용해보자.

	remove_if(l.begin(), l.end(), [](const String& str) {
		if (str.getNum() % 20 == 0)
			return true;
		return false;
	});

	for (String& d : l)
		cout << d << endl;

	save("소스.cpp");
}

=========================
Thu Apr 11 17:39:14 2019
=========================

//------------------------------------------------------------
//2019.STL 4.11 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
//   array	[]대신 사용
//   vector	dynamic array
//   deque	double-ended queue (메모리를 미리 할당해 앞뒤로 사용가능)
//--------------------------------------위는 객체크기만큼 할당,아래는 객체보다 크게 할당
// - list
//   forward_list
// 반복자 어댑터
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <algorithm>
#include <list>
using namespace std;

// "덱"은 한번에 큰 메모리 블록을 할당해서 사용한다.
// 상황에 따라 다른 자료구조들을 활용할 수 있어야 한다.
// 벡터는 연속되어 있는 자료구조 이지만, 덱은 연속적이지 않다
// 덱은 벡터보다는 크지만 크기를 확정지을 수 없다.
// 덱은 편리함 위주, 벡터는 속도 위주.

// 반복자 어댑터 - 자료구조와 알고리즘이 분리되어 있기 때문에
// 알고리즘에서 직접 자료구조의 원소를 삽입조작할 수 없다

int main()
{
	list<String> l;

	l.emplace(l.begin(), 10);
	l.emplace(l.begin(), 20);
	l.emplace(l.begin(), 30);
	l.emplace(l.begin(), 40);
	l.emplace(l.begin(), 50);
	l.emplace(l.begin(), 60);
	l.emplace(l.begin(), 70);
	l.emplace(l.begin(), 80);
	l.emplace(l.begin(), 90);

	//리스트에서 20의 배수를 제거해주세요. remove_if를 사용해보자.

	l.erase(remove_if(l.begin(), l.end(), [](const String& str) {
		if (str.getNum() % 20 == 0)
			return true;
		return false;
	}),l.end());

	for (String& d : l)
		cout << d << endl;

	save("소스.cpp");
}

=========================
Thu Apr 11 17:44:30 2019
=========================

//------------------------------------------------------------
//2019.STL 4.11 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
//   array	[]대신 사용
//   vector	dynamic array
//   deque	double-ended queue (메모리를 미리 할당해 앞뒤로 사용가능)
//--------------------------------------위는 객체크기만큼 할당,아래는 객체보다 크게 할당
// - list
//   forward_list
// 반복자 어댑터
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <algorithm>
#include <list>
using namespace std;

// "덱"은 한번에 큰 메모리 블록을 할당해서 사용한다.
// 상황에 따라 다른 자료구조들을 활용할 수 있어야 한다.
// 벡터는 연속되어 있는 자료구조 이지만, 덱은 연속적이지 않다
// 덱은 벡터보다는 크지만 크기를 확정지을 수 없다.
// 덱은 편리함 위주, 벡터는 속도 위주.

// 반복자 어댑터 - 자료구조와 알고리즘이 분리되어 있기 때문에
// 알고리즘에서 직접 자료구조의 원소를 삽입조작할 수 없다

int main()
{
	list<String> l;

	l.emplace(l.begin(), 10);
	l.emplace(l.begin(), 20);
	l.emplace(l.begin(), 30);
	l.emplace(l.begin(), 40);
	l.emplace(l.begin(), 50);
	l.emplace(l.begin(), 60);
	l.emplace(l.begin(), 70);
	l.emplace(l.begin(), 80);
	l.emplace(l.begin(), 90);

	//리스트에서 20의 배수를 제거해주세요. remove_if를 사용해보자.

	/*l.erase(remove_if(l.begin(), l.end(), [](const String& str) {
		if (str.getNum() % 20 == 0)
			return true;
		return false;
	}),l.end());*///작동은 하지만 리스트에는 맞지 않는 프로그램이다.(prev와 next포인터만 조정해주면 되기 때문)

	l.remove_if([](const String& s){
		return !(s.getNum() % 20);
	});

	for (String& d : l)
		cout << d << endl;

	save("소스.cpp");
}

=========================
Thu Apr 11 17:57:20 2019
=========================

//------------------------------------------------------------
//2019.STL 4.11 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
//   array	[]대신 사용
//   vector	dynamic array
//   deque	double-ended queue (메모리를 미리 할당해 앞뒤로 사용가능)
//--------------------------------------위는 객체크기만큼 할당,아래는 객체보다 크게 할당
// - list
//   forward_list
// 중간고사 4.25
// 반복자 어댑터
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <algorithm>
#include <list>
using namespace std;

// "덱"은 한번에 큰 메모리 블록을 할당해서 사용한다.
// 상황에 따라 다른 자료구조들을 활용할 수 있어야 한다.
// 벡터는 연속되어 있는 자료구조 이지만, 덱은 연속적이지 않다
// 덱은 벡터보다는 크지만 크기를 확정지을 수 없다.
// 덱은 편리함 위주, 벡터는 속도 위주.

// 반복자 어댑터 - 자료구조와 알고리즘이 분리되어 있기 때문에
// 알고리즘에서 직접 자료구조의 원소를 삽입조작할 수 없다

int main()
{
	list<String> str1{ 3,5,1 };
	list<String> str2{ 4,2,6 };

	str1.splice(str1.end(),str2);

	for (String& d : str1)
		cout << d << endl;


	for (String& e : str2)
		cout << e << endl;

	// str1 = str1 + str2로 만들어 보자
	save("소스.cpp");
}

=========================
Thu Apr 11 18:01:26 2019
=========================

//------------------------------------------------------------
//2019.STL 4.11 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
//   array	[]대신 사용
//   vector	dynamic array
//   deque	double-ended queue (메모리를 미리 할당해 앞뒤로 사용가능)
//--------------------------------------위는 객체크기만큼 할당,아래는 객체보다 크게 할당
// - list
//   forward_list
// 중간고사 4.25
// 반복자 어댑터
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <algorithm>
#include <list>
using namespace std;

// "덱"은 한번에 큰 메모리 블록을 할당해서 사용한다.
// 상황에 따라 다른 자료구조들을 활용할 수 있어야 한다.
// 벡터는 연속되어 있는 자료구조 이지만, 덱은 연속적이지 않다
// 덱은 벡터보다는 크지만 크기를 확정지을 수 없다.
// 덱은 편리함 위주, 벡터는 속도 위주.

// 반복자 어댑터 - 자료구조와 알고리즘이 분리되어 있기 때문에
// 알고리즘에서 직접 자료구조의 원소를 삽입조작할 수 없다

int main()
{
	list<String> str1{ 3,5,1 };
	list<String> str2{ 4,2,6 };

	str1.merge(str2,[](const String& s1,const String& s2){
		if (s1.getData() > s2.getData())
			return true;
		else
			return false;
	});
	//str1.splice(str1.end(),str2);

	for (String& d : str1)
		cout << d << endl;


	for (String& e : str2)
		cout << e << endl;

	// str1 = str1 + str2로 만들어 보자
	save("소스.cpp");
}

=========================
Thu Apr 11 18:03:41 2019
=========================

//------------------------------------------------------------
//2019.STL 4.11 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
//   array	[]대신 사용
//   vector	dynamic array
//   deque	double-ended queue (메모리를 미리 할당해 앞뒤로 사용가능)
//--------------------------------------위는 객체크기만큼 할당,아래는 객체보다 크게 할당
// - list
//   forward_list
// 중간고사 4.25
// 반복자 어댑터
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <algorithm>
#include <list>
using namespace std;

// "덱"은 한번에 큰 메모리 블록을 할당해서 사용한다.
// 상황에 따라 다른 자료구조들을 활용할 수 있어야 한다.
// 벡터는 연속되어 있는 자료구조 이지만, 덱은 연속적이지 않다
// 덱은 벡터보다는 크지만 크기를 확정지을 수 없다.
// 덱은 편리함 위주, 벡터는 속도 위주.

// 반복자 어댑터 - 자료구조와 알고리즘이 분리되어 있기 때문에
// 알고리즘에서 직접 자료구조의 원소를 삽입조작할 수 없다

int main()
{
	list<String> str1{ 3,5,1 };
	list<String> str2{ 4,2,6 };

	str1.merge(str2);
	//str1.splice(str1.end(),str2);

	for (String& d : str1)
		cout << d << endl;


	for (String& e : str2)
		cout << e << endl;

	// str1 = str1 + str2로 만들어 보자
	save("소스.cpp");
}

=========================
Thu Apr 11 18:04:24 2019
=========================

//------------------------------------------------------------
//2019.STL 4.11 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
//   array	[]대신 사용
//   vector	dynamic array
//   deque	double-ended queue (메모리를 미리 할당해 앞뒤로 사용가능)
//--------------------------------------위는 객체크기만큼 할당,아래는 객체보다 크게 할당
// - list
//   forward_list
// 중간고사 4.25
// 반복자 어댑터
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <algorithm>
#include <list>
using namespace std;

// "덱"은 한번에 큰 메모리 블록을 할당해서 사용한다.
// 상황에 따라 다른 자료구조들을 활용할 수 있어야 한다.
// 벡터는 연속되어 있는 자료구조 이지만, 덱은 연속적이지 않다
// 덱은 벡터보다는 크지만 크기를 확정지을 수 없다.
// 덱은 편리함 위주, 벡터는 속도 위주.

// 반복자 어댑터 - 자료구조와 알고리즘이 분리되어 있기 때문에
// 알고리즘에서 직접 자료구조의 원소를 삽입조작할 수 없다

int main()
{
	list<String> str1{ 3,5,1 };
	list<String> str2{ 4,2,6 };

	str1.merge(str2);
	//str1.splice(str1.end(),str2);

	for (const String& d : str1)
		cout << d << endl;


	for (const String& e : str2)
		cout << e << endl;

	// str1 = str1 + str2로 만들어 보자
	save("소스.cpp");
}

=========================
Thu Apr 11 18:07:25 2019
=========================

//------------------------------------------------------------
//2019.STL 4.11 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
//   array	[]대신 사용
//   vector	dynamic array
//   deque	double-ended queue (메모리를 미리 할당해 앞뒤로 사용가능)
//--------------------------------------위는 객체크기만큼 할당,아래는 객체보다 크게 할당
// - list
//   forward_list
// 중간고사 4.25
// 반복자 어댑터
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <algorithm>
#include <list>
using namespace std;

// "덱"은 한번에 큰 메모리 블록을 할당해서 사용한다.
// 상황에 따라 다른 자료구조들을 활용할 수 있어야 한다.
// 벡터는 연속되어 있는 자료구조 이지만, 덱은 연속적이지 않다
// 덱은 벡터보다는 크지만 크기를 확정지을 수 없다.
// 덱은 편리함 위주, 벡터는 속도 위주.

// 반복자 어댑터 - 자료구조와 알고리즘이 분리되어 있기 때문에
// 알고리즘에서 직접 자료구조의 원소를 삽입조작할 수 없다

int main()
{
	list<String> str1{ 3,5,1 };
	list<String> str2{ 4,2,6 };

	str1.sort();
	str2.sort();

	str1.merge(str2);
	//str1.splice(str1.end(),str2);
	//merge하기 전에 sort를 해야 제대로 합쳐질 거다.

	for (const String& d : str1)
		cout << d << endl;


	for (const String& e : str2)
		cout << e << endl;

	// str1 = str1 + str2로 만들어 보자
	save("소스.cpp");
}

=========================
Thu Apr 11 18:28:44 2019
=========================

//------------------------------------------------------------
//2019.STL 4.11 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
//   array	[]대신 사용
//   vector	dynamic array
//   deque	double-ended queue (메모리를 미리 할당해 앞뒤로 사용가능)
//--------------------------------------위는 객체크기만큼 할당,아래는 객체보다 크게 할당
// - list
//   forward_list
// 중간고사 4.25
// 반복자 어댑터
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <algorithm>
#include <fstream>
#include <iterator>
#include <list>
using namespace std;

// "덱"은 한번에 큰 메모리 블록을 할당해서 사용한다.
// 상황에 따라 다른 자료구조들을 활용할 수 있어야 한다.
// 벡터는 연속되어 있는 자료구조 이지만, 덱은 연속적이지 않다
// 덱은 벡터보다는 크지만 크기를 확정지을 수 없다.
// 덱은 편리함 위주, 벡터는 속도 위주.

// 반복자 어댑터 - 자료구조와 알고리즘이 분리되어 있기 때문에
// 알고리즘에서 직접 자료구조의 원소를 삽입조작할 수 없다

//소스.cpp에 사용된 단어를 길이 오름차순으로 출력
//list<string>을 사용해보자

int main()
{
	ifstream in("소스.cpp");
	list<string> strings;
	copy(istream_iterator<string>(in), istream_iterator<string>(), inserter(strings, strings.begin()));
	strings.sort([](const string& a, const string& b) {
		return a.length() < b.length();
	});

	for (const string& str : strings)
		cout << str << endl;
	//list<string> strings{	copy(istream_iterator<string>(in),istream_iterator<string>(),strings.begin()	}리스트에 제대로 들어가지 않는다.
	save("소스.cpp");
}

=========================
Thu Apr 11 18:50:00 2019
=========================

//------------------------------------------------------------
//2019.STL 4.11 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
//   array	[]대신 사용
//   vector	dynamic array
//   deque	double-ended queue (메모리를 미리 할당해 앞뒤로 사용가능)
//--------------------------------------위는 객체크기만큼 할당,아래는 객체보다 크게 할당
// - list
//   forward_list
// 중간고사 4.25
// 반복자 어댑터
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <algorithm>
#include <fstream>
#include <iterator>
#include <list>
using namespace std;

// "덱"은 한번에 큰 메모리 블록을 할당해서 사용한다.
// 상황에 따라 다른 자료구조들을 활용할 수 있어야 한다.
// 벡터는 연속되어 있는 자료구조 이지만, 덱은 연속적이지 않다
// 덱은 벡터보다는 크지만 크기를 확정지을 수 없다.
// 덱은 편리함 위주, 벡터는 속도 위주.

// 반복자 어댑터 - 자료구조와 알고리즘이 분리되어 있기 때문에
// 알고리즘에서 직접 자료구조의 원소를 삽입조작할 수 없다

//소스.cpp에 사용된 단어를 길이 오름차순으로 출력
//list<string>을 사용해보자

int main()
{
	ifstream in("소스.cpp");
	list<string> strings;
	list<string> len_five;
	copy(istream_iterator<string>(in), istream_iterator<string>(), inserter(strings, strings.begin()));
	strings.sort([](const string& a, const string& b) {
		return a.length() < b.length();
	});

	auto len5 = find_if(strings.begin(),strings.end(),[](const string& s) {
		return s.length() == 5;
	});

	auto len6 = find_if(strings.begin(), strings.end(), [](const string& s) {
		return s.length() == 5;
	});

	for (auto i = len5; i != len6; ++i)
		cout << *i << endl;

	len_five.splice(len_five.begin(), strings, len5, len6);

	ofstream out("길이5.txt");
	copy(len_five.begin(), len_five.end(), ostream_iterator<string>(out, " "));

	//길이 순으로 정렬한 리스트에서 길이가 5인 단어를 
	//list<string> len5;으로 이동하자.
	//"길이5.txt"에 저장하자.;
	//list<string> strings{	copy(istream_iterator<string>(in),istream_iterator<string>(),strings.begin()	}리스트에 제대로 들어가지 않는다.
	save("소스.cpp");
}

=========================
Thu Apr 11 18:50:50 2019
=========================

//------------------------------------------------------------
//2019.STL 4.11 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
//   array	[]대신 사용
//   vector	dynamic array
//   deque	double-ended queue (메모리를 미리 할당해 앞뒤로 사용가능)
//--------------------------------------위는 객체크기만큼 할당,아래는 객체보다 크게 할당
// - list
//   forward_list
// 중간고사 4.25
// 반복자 어댑터
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <algorithm>
#include <fstream>
#include <iterator>
#include <list>
using namespace std;

// "덱"은 한번에 큰 메모리 블록을 할당해서 사용한다.
// 상황에 따라 다른 자료구조들을 활용할 수 있어야 한다.
// 벡터는 연속되어 있는 자료구조 이지만, 덱은 연속적이지 않다
// 덱은 벡터보다는 크지만 크기를 확정지을 수 없다.
// 덱은 편리함 위주, 벡터는 속도 위주.

// 반복자 어댑터 - 자료구조와 알고리즘이 분리되어 있기 때문에
// 알고리즘에서 직접 자료구조의 원소를 삽입조작할 수 없다

//소스.cpp에 사용된 단어를 길이 오름차순으로 출력
//list<string>을 사용해보자

int main()
{
	ifstream in("소스.cpp");
	list<string> strings;
	list<string> len_five;
	copy(istream_iterator<string>(in), istream_iterator<string>(), inserter(strings, strings.begin()));
	strings.sort([](const string& a, const string& b) {
		return a.length() < b.length();
	});

	auto len5 = find_if(strings.begin(),strings.end(),[](const string& s) {
		return s.length() == 5;
	});

	auto len6 = find_if(strings.begin(), strings.end(), [](const string& s) {
		return s.length() == 6;
	});

	for (auto i = len5; i != len6; ++i)
		cout << *i << endl;

	len_five.splice(len_five.begin(), strings, len5, len6);

	ofstream out("길이5.txt");
	copy(len_five.begin(), len_five.end(), ostream_iterator<string>(out, " "));

	//길이 순으로 정렬한 리스트에서 길이가 5인 단어를 
	//list<string> len5;으로 이동하자.
	//"길이5.txt"에 저장하자.;
	//list<string> strings{	copy(istream_iterator<string>(in),istream_iterator<string>(),strings.begin()	}리스트에 제대로 들어가지 않는다.
	save("소스.cpp");
}

=========================
Thu Apr 11 18:52:05 2019
=========================

//------------------------------------------------------------
//2019.STL 4.11 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
//   array	[]대신 사용
//   vector	dynamic array
//   deque	double-ended queue (메모리를 미리 할당해 앞뒤로 사용가능)
//--------------------------------------위는 객체크기만큼 할당,아래는 객체보다 크게 할당
// - list
//   forward_list
// 중간고사 4.25
// 반복자 어댑터
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <algorithm>
#include <fstream>
#include <iterator>
#include <list>
using namespace std;

// "덱"은 한번에 큰 메모리 블록을 할당해서 사용한다.
// 상황에 따라 다른 자료구조들을 활용할 수 있어야 한다.
// 벡터는 연속되어 있는 자료구조 이지만, 덱은 연속적이지 않다
// 덱은 벡터보다는 크지만 크기를 확정지을 수 없다.
// 덱은 편리함 위주, 벡터는 속도 위주.

// 반복자 어댑터 - 자료구조와 알고리즘이 분리되어 있기 때문에
// 알고리즘에서 직접 자료구조의 원소를 삽입조작할 수 없다

//소스.cpp에 사용된 단어를 길이 오름차순으로 출력
//list<string>을 사용해보자

int main()
{
	ifstream in("소스.cpp");
	list<string> strings;
	list<string> len_five;
	copy(istream_iterator<string>(in), istream_iterator<string>(), inserter(strings, strings.begin()));
	strings.sort([](const string& a, const string& b) {
		return a.length() < b.length();
	});

	auto len5 = find_if(strings.begin(),strings.end(),[](const string& s) {
		return s.length() == 5;
	});

	auto len6 = find_if(strings.begin(), strings.end(), [](const string& s) {
		return s.length() == 6;
	});

	for (auto i = len5; i != len6; ++i)
		cout << *i << endl;

	ofstream out("길이5.txt");
	copy(len5, len6, ostream_iterator<string>(out, " "));

	//길이 순으로 정렬한 리스트에서 길이가 5인 단어를 
	//list<string> len5;으로 이동하자.
	//"길이5.txt"에 저장하자.;
	//list<string> strings{	copy(istream_iterator<string>(in),istream_iterator<string>(),strings.begin()	}리스트에 제대로 들어가지 않는다.
	save("소스.cpp");
}

=========================
Thu Apr 11 18:52:13 2019
=========================

//------------------------------------------------------------
//2019.STL 4.11 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
//   array	[]대신 사용
//   vector	dynamic array
//   deque	double-ended queue (메모리를 미리 할당해 앞뒤로 사용가능)
//--------------------------------------위는 객체크기만큼 할당,아래는 객체보다 크게 할당
// - list
//   forward_list
// 중간고사 4.25
// 반복자 어댑터
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <algorithm>
#include <fstream>
#include <iterator>
#include <list>
using namespace std;

// "덱"은 한번에 큰 메모리 블록을 할당해서 사용한다.
// 상황에 따라 다른 자료구조들을 활용할 수 있어야 한다.
// 벡터는 연속되어 있는 자료구조 이지만, 덱은 연속적이지 않다
// 덱은 벡터보다는 크지만 크기를 확정지을 수 없다.
// 덱은 편리함 위주, 벡터는 속도 위주.

// 반복자 어댑터 - 자료구조와 알고리즘이 분리되어 있기 때문에
// 알고리즘에서 직접 자료구조의 원소를 삽입조작할 수 없다

//소스.cpp에 사용된 단어를 길이 오름차순으로 출력
//list<string>을 사용해보자

int main()
{
	ifstream in("소스.cpp");
	list<string> strings;
	list<string> len_five;
	copy(istream_iterator<string>(in), istream_iterator<string>(), inserter(strings, strings.begin()));
	strings.sort([](const string& a, const string& b) {
		return a.length() < b.length();
	});

	auto len5 = find_if(strings.begin(),strings.end(),[](const string& s) {
		return s.length() == 5;
	});

	auto len6 = find_if(strings.begin(), strings.end(), [](const string& s) {
		return s.length() == 6;
	});

	for (auto i = len5; i != len6; ++i)
		cout << *i << endl;

	ofstream out("길이5.txt");
	copy(len5, len6, ostream_iterator<string>(out, " "));

	//길이 순으로 정렬한 리스트에서 길이가 5인 단어를 
	//list<string> len5;으로 이동하자.
	//"길이5.txt"에 저장하자.;
	//list<string> strings{	copy(istream_iterator<string>(in),istream_iterator<string>(),strings.begin()	}리스트에 제대로 들어가지 않는다.
	save("소스.cpp");
}

=========================
Thu Apr 11 18:53:19 2019
=========================

//------------------------------------------------------------
//2019.STL 4.11 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
//   array	[]대신 사용
//   vector	dynamic array
//   deque	double-ended queue (메모리를 미리 할당해 앞뒤로 사용가능)
//--------------------------------------위는 객체크기만큼 할당,아래는 객체보다 크게 할당
// - list
//   forward_list
// 중간고사 4.25
// 반복자 어댑터
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <algorithm>
#include <fstream>
#include <iterator>
#include <list>
using namespace std;

// "덱"은 한번에 큰 메모리 블록을 할당해서 사용한다.
// 상황에 따라 다른 자료구조들을 활용할 수 있어야 한다.
// 벡터는 연속되어 있는 자료구조 이지만, 덱은 연속적이지 않다
// 덱은 벡터보다는 크지만 크기를 확정지을 수 없다.
// 덱은 편리함 위주, 벡터는 속도 위주.

// 반복자 어댑터 - 자료구조와 알고리즘이 분리되어 있기 때문에
// 알고리즘에서 직접 자료구조의 원소를 삽입조작할 수 없다

//소스.cpp에 사용된 단어를 길이 오름차순으로 출력
//list<string>을 사용해보자

int main()
{
	ifstream in("소스.cpp");
	list<string> strings;
	list<string> len_five;
	copy(istream_iterator<string>(in), istream_iterator<string>(), inserter(strings, strings.begin()));
	strings.sort([](const string& a, const string& b) {
		return a.length() < b.length();
	});

	auto len5 = find_if(strings.begin(),strings.end(),[](const string& s) {
		return s.length() == 5;
	});

	auto len6 = find_if(strings.begin(), strings.end(), [](const string& s) {
		return s.length() == 6;
	});

	for (auto i = len5; i != len6; ++i)
		cout << *i << endl;

	ofstream out("길이5.txt");
	copy(len5, len6, ostream_iterator<string>(out, "" ""));

	//길이 순으로 정렬한 리스트에서 길이가 5인 단어를 
	//list<string> len5;으로 이동하자.
	//"길이5.txt"에 저장하자.;
	//list<string> strings{	copy(istream_iterator<string>(in),istream_iterator<string>(),strings.begin()	}리스트에 제대로 들어가지 않는다.
	save("소스.cpp");
}

=========================
Thu Apr 11 19:00:25 2019
=========================

//------------------------------------------------------------
//2019.STL 4.11 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
//   array	[]대신 사용
//   vector	dynamic array
//   deque	double-ended queue (메모리를 미리 할당해 앞뒤로 사용가능)
//--------------------------------------위는 객체크기만큼 할당,아래는 객체보다 크게 할당
//   list
// - forward_list
// 중간고사 4.25
// 반복자 어댑터
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <list>
using namespace std;

// "덱"은 한번에 큰 메모리 블록을 할당해서 사용한다.
// 상황에 따라 다른 자료구조들을 활용할 수 있어야 한다.
// 벡터는 연속되어 있는 자료구조 이지만, 덱은 연속적이지 않다
// 덱은 벡터보다는 크지만 크기를 확정지을 수 없다.
// 덱은 편리함 위주, 벡터는 속도 위주.

// 반복자 어댑터 - 자료구조와 알고리즘이 분리되어 있기 때문에
// 알고리즘에서 직접 자료구조의 원소를 삽입조작할 수 없다

//소스.cpp에 사용된 단어를 길이 오름차순으로 출력
//list<string>을 사용해보자

int main()
{
	list<int> numbers{ 1,3,5,7,9 };

	//void print()
	cout << typeid(numbers.begin()).name() << endl;
	//print(numbers.begin(), numbers.end()); // 함수 프로그램 해보자
	save("소스.cpp");
}

=========================
Thu Apr 11 19:03:46 2019
=========================

//------------------------------------------------------------
//2019.STL 4.11 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 2. 순차 컨테이너 ( Sequence Container( Homogeneous data type ) )
//   array	[]대신 사용
//   vector	dynamic array
//   deque	double-ended queue (메모리를 미리 할당해 앞뒤로 사용가능)
//--------------------------------------위는 객체크기만큼 할당,아래는 객체보다 크게 할당
//   list
// - forward_list
// 중간고사 4.25
// 반복자 어댑터
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <list>
using namespace std;
void print(list<int>::iterator b, list<int>::iterator e);

// "덱"은 한번에 큰 메모리 블록을 할당해서 사용한다.
// 상황에 따라 다른 자료구조들을 활용할 수 있어야 한다.
// 벡터는 연속되어 있는 자료구조 이지만, 덱은 연속적이지 않다
// 덱은 벡터보다는 크지만 크기를 확정지을 수 없다.
// 덱은 편리함 위주, 벡터는 속도 위주.

// 반복자 어댑터 - 자료구조와 알고리즘이 분리되어 있기 때문에
// 알고리즘에서 직접 자료구조의 원소를 삽입조작할 수 없다

//소스.cpp에 사용된 단어를 길이 오름차순으로 출력
//list<string>을 사용해보자

int main()
{
	list<int> numbers{ 1,3,5,7,9 };

	
	cout << typeid(numbers.begin()).name() << endl;
	print(numbers.begin(), numbers.end()); // 함수 프로그램 해보자
	save("소스.cpp");
}

void print(list<int>::iterator b, list<int>::iterator e)
{
	while (b != e)
		cout << *b++;
}

=========================
Tue Apr 16 17:32:31 2019
=========================

//------------------------------------------------------------
//2019.STL 4.16 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 반복자의 정체는? - STL 반복자가 되기에 필요한 것은?
// 반복자 어댑터
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <list>
#include <vector>
using namespace std;
void print(vector<int>::iterator b, vector<int>::iterator e);

// "덱"은 한번에 큰 메모리 블록을 할당해서 사용한다.
// 상황에 따라 다른 자료구조들을 활용할 수 있어야 한다.
// 벡터는 연속되어 있는 자료구조 이지만, 덱은 연속적이지 않다
// 덱은 벡터보다는 크지만 크기를 확정지을 수 없다.
// 덱은 편리함 위주, 벡터는 속도 위주.

// 반복자 어댑터 - 자료구조와 알고리즘이 분리되어 있기 때문에
// 알고리즘에서 직접 자료구조의 원소를 삽입조작할 수 없다

//소스.cpp에 사용된 단어를 길이 오름차순으로 출력
//list<string>을 사용해보자

int main()
{
	vector<int> numbers{ 1,3,5,7,9 };

	
	cout << typeid(numbers.begin()).name() << endl;
	print(numbers.begin(), numbers.end()); // 함수 프로그램 해보자
	save("소스.cpp");
}

void print(vector<int>::iterator b, vector<int>::iterator e)
{
	while (b != e)
		cout << *b++;
}

=========================
Tue Apr 16 17:50:20 2019
=========================

//------------------------------------------------------------
//2019.STL 4.16 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 반복자의 정체는? - STL 반복자가 되기에 필요한 것은?
// 반복자 어댑터
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <string>
using namespace std;
template <typename T>
T add(T a, T b);

// "덱"은 한번에 큰 메모리 블록을 할당해서 사용한다.
// 상황에 따라 다른 자료구조들을 활용할 수 있어야 한다.
// 벡터는 연속되어 있는 자료구조 이지만, 덱은 연속적이지 않다
// 덱은 벡터보다는 크지만 크기를 확정지을 수 없다.
// 덱은 편리함 위주, 벡터는 속도 위주.

// 반복자 어댑터 - 자료구조와 알고리즘이 분리되어 있기 때문에
// 알고리즘에서 직접 자료구조의 원소를 삽입조작할 수 없다

//소스.cpp에 사용된 단어를 길이 오름차순으로 출력
//list<string>을 사용해보자

int main()
{
	cout << add(1, 2) << endl;
	cout << add<string>("Hello, ", "world!") << endl;
	save("소스.cpp");
}

template <typename T>
T add(T a, T b)
{
	return a + b;
}

=========================
Tue Apr 16 17:53:42 2019
=========================

//------------------------------------------------------------
//2019.STL 4.16 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 반복자의 정체는? - STL 반복자가 되기에 필요한 것은?
// 반복자 어댑터
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <string>
using namespace std;
template <typename T>
T add(T a, T b);

// "덱"은 한번에 큰 메모리 블록을 할당해서 사용한다.
// 상황에 따라 다른 자료구조들을 활용할 수 있어야 한다.
// 벡터는 연속되어 있는 자료구조 이지만, 덱은 연속적이지 않다
// 덱은 벡터보다는 크지만 크기를 확정지을 수 없다.
// 덱은 편리함 위주, 벡터는 속도 위주.

// 반복자 어댑터 - 자료구조와 알고리즘이 분리되어 있기 때문에
// 알고리즘에서 직접 자료구조의 원소를 삽입조작할 수 없다

//소스.cpp에 사용된 단어를 길이 오름차순으로 출력
//list<string>을 사용해보자

int main()
{
	cout << add(1, 2) << endl;
	cout << add<string>("Hello, ", "world!") << endl;
	save("소스.cpp");
}

template <typename T>
T add(T a, T b)
{
	//만일 T가 덧셈 가능하다면 -- type_traits(타입 특성)
	cout << boolalpha << is_arithmetic<T>() << endl;
	return a + b;
}

=========================
Tue Apr 16 18:08:08 2019
=========================

//------------------------------------------------------------
//2019.STL 4.16 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 반복자의 정체는? - STL 반복자가 되기에 필요한 것은?
// 반복자 어댑터
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <vector>
#include <list>
#include <forward_list>
#include <iterator>
using namespace std;
template <typename Iter>
void cat(Iter b);

// "덱"은 한번에 큰 메모리 블록을 할당해서 사용한다.
// 상황에 따라 다른 자료구조들을 활용할 수 있어야 한다.
// 벡터는 연속되어 있는 자료구조 이지만, 덱은 연속적이지 않다
// 덱은 벡터보다는 크지만 크기를 확정지을 수 없다.
// 덱은 편리함 위주, 벡터는 속도 위주.

// 반복자 어댑터 - 자료구조와 알고리즘이 분리되어 있기 때문에
// 알고리즘에서 직접 자료구조의 원소를 삽입조작할 수 없다

//소스.cpp에 사용된 단어를 길이 오름차순으로 출력
//list<string>을 사용해보자

int main()
{
	vector<int> v;
	cat(v.begin());

	cat(list<int>::iterator());
	cat(forward_list<int>::iterator());

	cat(istream_iterator<int>());
	cat(ostream_iterator<int>(cout));
	save("소스.cpp");
}

template <typename Iter>
void cat(Iter iter)
{
	cout << typeid(iterator_traits<Iter>::iterator_category).name() << endl;
}



=========================
Tue Apr 16 18:10:43 2019
=========================

//------------------------------------------------------------
//2019.STL 4.16 목9,10
// - smart pointer
// 언제나 그러하듯이 프로그래밍은 훈련을 동반한다.
// 모르면 맞아야지
// STL은 속도를 우선한다
// C++의 장점은 프로그래머 마음대로 제한없이 들여다 볼 수 있다는 것이다.
// 반복자의 정체는? - STL 반복자가 되기에 필요한 것은?
// 반복자 어댑터
//------------------------------------------------------------
#include "String.h"
#include "save.h"
#include <vector>
#include <list>
#include <forward_list>
#include <iterator>
using namespace std;
template <typename Iter>
void cat(Iter b);

// "덱"은 한번에 큰 메모리 블록을 할당해서 사용한다.
// 상황에 따라 다른 자료구조들을 활용할 수 있어야 한다.
// 벡터는 연속되어 있는 자료구조 이지만, 덱은 연속적이지 않다
// 덱은 벡터보다는 크지만 크기를 확정지을 수 없다.
// 덱은 편리함 위주, 벡터는 속도 위주.

// 반복자 어댑터 - 자료구조와 알고리즘이 분리되어 있기 때문에
// 알고리즘에서 직접 자료구조의 원소를 삽입조작할 수 없다

//소스.cpp에 사용된 단어를 길이 오름차순으로 출력
//list<string>을 사용해보자

int main()
{
	vector<int> v;
	cat(v.begin());

	cat(list<int>::iterator());
	cat(forward_list<int>::iterator());

	cat(istream_iterator<int>());
	cat(ostream_iterator<int>(cout));

	double n;
	cat(&n);
	save("소스.cpp");
}

template <typename Iter>
void cat(Iter iter)
{
	cout << typeid(iterator_traits<Iter>::iterator_category).name() << endl;
	cout << typeid(iterator_traits<Iter>::value_type).name() << endl;
}

